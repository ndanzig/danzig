<!-- output file generated by BM Utilities -->
<html>

<p><a href="./3376fm.html"><img src="fm2html-toc.gif">Table of Contents</a>  <a href="3376c410.html#H645"><img src="fm2html-previous.gif">DOS</a><br>
<head>
<title>
TCP/IP Tutorial and Technical Overview
</title>
<body>

<h2><a name="ncs">4.11  Network Computing System (NCS)</a>
</h2>
<br><br><a name=figncs1>
<img src="3376ncs.gif"></a>
<br><i>Figure: Network Computing System (NCS)</i><br><br>
<p><a name=index1730>The</a> APOLLO Network Computing System (NCS) is an
implementation of the Network Computing Architecture developed to provide tools
for designing, implementing and supporting applications requiring distributed
data and distributed computing. This is achieved through implementation of NCS
on top of the Remote Procedure Call interface, which is different from Sun RPC.
<p><a name=index1732>The</a> Network Computing Architecture is object-oriented.
This allows programs to access objects through interfaces no matter which
machines they communicate with. These types of programs have a simpler design
and are less susceptible to hardware and network changes.
<p>An object is an entity managed by defined operations having a type
specifying the class or category. For example, a disk file is an object and it
can be an ASCII type.
<p>An interface is a set of operations that manipulate the objects.
<p>The Network Computing Architecture uses an expanded concept called
replicated objects which are copies of an object that have the same identifier.
It can be weakly or strongly consistent. Weakly consistent replicated objects
can be accessed even if they are not identical. Strongly consistent replicated
objects can only be accessed when they are identical. The use of one or the
other depends on the performance, availability and consistency required.
<p>Distributed data and processing is achieved through the use of the following
components:
<ol>
<li>The <i>Remote Procedure Call</i> (RPC) runtime library
<li>The <i>Network Interface Definition Language</i> (NIDL) compiler
<li>The <i>Location Broker</i>
</ol>
<p><a name=index1733>The</a> <i>Network Computing Kernel</i> consists of the
Location Broker and the RPC runtime library, which provides runtime support for
network computing. This kernel and the NIDL compiler support the development
and implementation of distributed applications.

<h4><a name="H648">4.11.0.1  NCS RPC</a>
</h4>
<a name=index1734>The</a> NCS RPC can use the Domain network communications
protocols (DDS) and the DARPA Internet Protocols (UDP/IP). The selection is
made by the destination address given so that a program can access a Domain and
non-Domain entity.
<p>The Berkeley socket concept is used in NCS RPC. It can listen to more than
one socket identified by a socket address divided into address family (which
defines the structure of the address), network address (host address) and port
number (endpoint address).
<br><br><a name=figncs>
<img src="3376f128.gif"></a>
<br><i>Figure: NCS (Components of the Network Computing System)</i><br><br>
<p>The client procedure uses standard procedure calling conventions, but it is
remotely executed by the server. The program that makes remote procedure calls
to request operations is called an RPC client. It does not know how an
interface is implemented and may not know the location of the server.
<p>The process that receives the operation request packet from the RPC runtime
library is the RPC server. It is responsible for sending the response with the
results of the operation. A server can export an interface for more than one
object.
<p>The client process has three components: the client procedure that makes
calls, the client stub and the RPC runtime library. The client stub is
responsible for making use of the RPC runtime library to have the client
procedure's calls executed.
<p>The server process has three components: the manager procedures
corresponding to the client application, the server stub corresponding to the
client stub and the RPC runtime library. The server can be called a manager.
<p>When the client requests an operation on a particular object through an RPC
it must indicate the object on which the operation is to be performed and the
server that exports the interface containing the operation. This information is
passed by a handle, created and managed by several calls provided by NCS. The
representation of the server in the handle is called binding. The client may or
may not bind the handle by requesting an RPC with the following states:
<ul>
<li><a name=index1736>Unbound</a> - no identification (RPC broadcasts to all
hosts on the local network and accepts the first response)
<li>Bound-to-host - handle contains host identification without a specific
server (an RPC is sent to the host and the Local Location Broker finds the
right port)
<li>Bound-to-server - handle contains full identification (an RPC is sent to
the specific server port).
</ul>
<p><a name=index1737>The</a> stubs are responsible for making the remote call
as transparent as possible. They mediate between the client and the manager
procedures, converting data for the use of RPC runtime routines.
<p>The RPC runtime library transmits RPC packets containing routines, tables
and data for supporting communication between the client and server stub. There
are three types of calls:
<ul>
<li><a name=index1738>Client</a> calls used to manipulate the handle and to
send packets.
<li>Server calls used to create sockets, register interfaces and return object
identification.
<li>Conversion calls used to determine the socket address for a specific host
and return the host name and socket port number related to a socket address.
</ul>

<h4><a name="H650">4.11.0.2  Network Interface Definition Language</a>
</h4>
<a name=index1739>The</a> NIDL is a development language that completely
defines the interface and each RPC's parameters. Two syntaxes can be used, one
more comfortable for C programmers and the other for Pascal programmers.
<p>The NIDL compiler translates the NIDL commands into executable stubs that
will be linked with clients and servers. These stubs will be generated in C
source code but are fully compatible with Pascal programs.
<br><br><a name=fignidl>
<img src="3376f129.gif"></a>
<br><i>Figure: NIDL Compiler</i> - Generated files.<br><br>
<p>The NIDL Compiler generates two client stub files: name_cstub.c and
name_cswtch.c. The second one is a switch file used to create replicated
servers to provide access to a replicated object and ensure consistency. The
client calls are sent to the client switch that contains the public procedures,
leaving the client stub only with the private procedures.
<p>The stub generated can have two major responsibilities:
<ul>
<li>Copying and converting data - The simplest stubs have only this procedure
of argument passing and data conversion. All stubs marshal and unmarshal values
into and from the RPC packet. The client stub marshals the input parameters to
send the packet to the server and unmarshals the output parameters from the
reply packet. The server stub unmarshals the input parameters from the RPC
packet sent from the client and sends them to the interface manager and
marshals the output parameters to send them to the client. In addition each
stub checks the data representation format indicated in the transmitted packet.
Every system sends data in its native format and the stubs convert them to the
receiver's representation. It's important to note that no stub sends data in a
standard format so, if both systems use the same data representation, there is
no need to convert data.
<li>Binding with a remote interface - NIDL manages the object and binding
information in the following ways:
<ul>
<li>Explicit handle - the client explicitly passes the handle parameter in each
operation which is passed to the server's manager routines
<li>Implicit handle - the handle is a single global variable making the RPC
look more like an ordinary procedure call but restricting it to a one-server
system
<li>Manual binding - the client makes all calls that create and manage the
handle
<li>Automatic binding - the client calls an auto-binding routine for each RPC
and an auto-unbinding routine after the response, thus trading performance for
convenience.
</ul>
</ul>

<h4><a name="H652">4.11.0.3  The Location Broker</a>
</h4>
<a name=index1742>The</a> Location Broker is used by the client to request
information about objects and interfaces. This information is registered in the
Location Broker by the servers.
<p>The Location Broker is composed of three components:
<ul>
<li><a name=index1745>Local</a> Location Broker (LLB) - maintains information
about objects and interfaces on the local host and provides it to remote or
local application programs. It also provides the client with the LLB's
forwarding facility, which eliminates the need for a client to know the
specific port that a server uses.
<li><a name=index1748>Global</a> Location Broker (GLB) - maintains information
about objects and interfaces throughout the network.
<li><a name=index1749>Location</a> Broker Client Agent - is a set of routines
called by application programs to access LLB and GLB databases. The client may
know the host on which the object is located and can directly interrogate the
remote host's LLB; otherwise it would take the GLB route.
</ul>
<p>The GLB may have several replicas running to ensure the availability of the
information. To ensure the consistency of the replicas' data all
<a name=index1750>the</a> manipulation is done by the Data Replication Manager
(DRM), which propagates any change in the database. The DRM uses a replica list
containing the location of every replica. Clients are allowed to do lockups and
updates even in the propagation procedures, which gives weak consistency but
high availability.
<p><a name=index1752>The</a> Location Broker database has the following fields:
<ul>
<li>Object UUID - object identifier
<li>Type UUID - type of the object identifier
<li>Interface UUID - interface of the object identifier
<li>Flags - indication of a global object
<li>Annotation - user defined
<li>Socket address length - socket address field length
<li>Socket address - location of the server
</ul>
<p>Here are some definitions:
<ul>
<li><i>UUID</i> <a name=index1753>stands</a> for <i>Universal Unique
IDentifier</i>, that is, a 128-bit value used for identification. No other
object, type, or interface can use a UUID that is already assigned.
<li><i>Object</i>: an entity that is manipulated by well-known operations. Disk
files and printers are examples of objects. Objects are accessed through
interfaces. Every object has a type.
<li><i>Type</i>: a class of object. All objects of a specific type can be
accessed through the same interface or interfaces.
<li><i>Interface</i>: a set of operations. The Network Computing Architecture
specifies a Network Interface Definition Language (NIDL) for defining
interfaces.
<li><i>NIDL</i>: a declarative language for the definitions of interfaces.
<li><i>NIDL Compiler</i>: an NCS tool that converts an interface definition,
written in NIDL, into several program modules, including source code for client
and server stub.
</ul>

<h3><a name="H653">4.11.1  Implementations</a>
</h3>

<h4><a name="ncsvm">4.11.1.1  VM</a>
</h4>
<p><a name=index1755>The</a> following list indicates the parts and versions of
NCS that were ported to VM:
<ul>
<li>NIDL Compiler 1.0
<li>Network Computing Kernel (NCK) 1.1
</ul>
<p>The IBM VM implementation of NCS differs from the Apollo Computer, Inc.
implementation of NCS:
<ul>
<li>The IBM VM implementation of NCS contains support for the Non-Replicated
Global Location Broker Daemon (NRGLBD).
<li>It does not contain support for the Global Location Broker Daemon (GLBD).
<li>It does not contain support for the Data Replication Manager Administrative
Tool (DRM_ADMIN).
<li>It does not support multitasking, forking, spanning a task, or Apollo's
Concurrent Program Support (CPS).
<li>It only supports the Internet Protocol (IP).
<li>It fixed several EBCDIC-to-ASCII translation table errors as well as the
IBM floating point and IEEE floating point translation errors which were
present in the NCS V1.0.
<li>The NCS regular enum data type requires fullword (4 bytes) enumeration
usage in the IBM C/370 Compiler.
</ul>
<p>The VM implementation of NCS consists of three virtual machines:
<ul>
<li>NCS virtual machine, which has two minidisks:
<ol>
<li>191 minidisk: the files stored there should be accessible to anyone who
wants to run NCS. This disk is a repository for the NCS executables, NCS IDL
and header files, LIBNCK (RPC runtime library), sample programs.
<li>195 minidisk: These files should be accessible only to qualified users who
are acting as NCS database or network administrators. The NCS 195 disk contains
the NCS executable LB_ADMIN. The LB_ADMIN function allows the user to add,
delete, or update any record in the NCS Global Location Broker or Local
Location Broker databases.
</ol>
<li>NCSGLBD virtual machine, where the NCS Non-Replicated Global Location
Broker daemon is run. It controls the Global Location Broker database, that is,
it helps clients to locate servers on the network or internet. The NRGLBD
should be running on this host only if neither GLBD or NRGLBD is running
anywhere else in your network.
<li>NCSLLBD virtual machine, where the NCS Local Location Broker daemon (LLBD)
is run. It manages the LLB database where information about local NCS-based
servers are stored. The LLBD must be run on each host where NCS-based programs
are run.
</ul>

<h4><a name="H655">4.11.1.2  MVS</a>
</h4>
<p>The same parts and versions of NCS were ported to MVS as in VM. Please refer
to <a href="3376c411.html#ncsvm">VM</a>.
<p>The MVS implementation of NCS consists of two servers:
<ul>
<li>NCSGLBD server, where the NCS Non-Replicated Global Location Broker daemon
is run. It controls the Global Location Broker database. It also helps clients
to locate servers on the network. The NRGLLD should be running on this host
only if neither GLBD or NRGLBD is running anywhere else in your network.
<li>NCSLLBD server: where the NCS Local Location Broker daemon (LLBD) is run.
It manages the LLB database where information about local NCS-based servers are
stored. The LLBD must be run on each host where NCS-based programs are run.
<p>The runnidl, runcpp, uuid@gen and lb@admin commands are available. Please
refer to <i>IBM TCP/IP Version 3 Release 1 for MVS: User's Guide</i> and <i>IBM
TCP/IP Version 3 Release 1 for MVS: Programmer's Reference</i> for details.
</ul>

<h4><a name="H656">4.11.1.3  OS/400</a>
</h4>
<p>NCS is not implemented in TCP/IP on the OS/400 system.

<h4><a name="H657">4.11.1.4  AIX/ESA</a>
</h4>
<p><i>NCS for IBM AIX/ESA</i> is a port of Hewlett-Packard/Apollo's NCS Version
1.5.1 to the IBM AIX/ESA. For details, please refer to <i>Network Computing
System for AIX/ESA Planning and Administration</i>.

<h4><a name="H658">4.11.1.5  AIX/6000</a>
</h4>
<p>NCS with the Network Computing Kernel, runtime services and the NIDL
compiler are supported in both AIX Versions.
<p>The implementation includes the <i>Local Location Broker </i> (llbd daemon)
and the <i>Non-replicated Global Location Broker</i> (nrglbd daemon). Both
daemons are controlled by the SRC (System Resource Controller) and can be
started by uncommenting the <i>#startsrc -s llbd</i> and <i>#startsrc -s
nrglbd</i> lines in the <b>/etc/rc.ncs</b> file. For more details, please refer
to <i>AIX Version 3.2 for RISC System/6000 Communication Concepts and
Procedures</i> and <i>AIX Version 3.2 for RISC System/6000 General Programming
Concepts</i>.
<p>The <i>lb_admin</i>, <i>nidl</i> and <i>uuid_gen</i> commands are available.
Please see the online InfoExplorer facility for details.

<h4><a name="H659">4.11.1.6  OS/2</a>
</h4>
<p>NCS is not implemented in TCP/IP for OS/2.

<h4><a name="H660">4.11.1.7  DOS</a>
</h4>
<p>NCS is not implemented in TCP/IP for DOS.

<p><a href="./3376fm.html"><img src="fm2html-toc.gif">Table of Contents</a>  <a href="3376c412.html#nfs"><img src="fm2html-next.gif">Network
File System (NFS)</a><br>
</html>
