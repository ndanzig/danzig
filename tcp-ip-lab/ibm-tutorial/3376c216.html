<!-- output file generated by BM Utilities -->
<html>

<p><a href="./3376fm.html"><img src="fm2html-toc.gif">Table of Contents</a>  <a href="3376c215.html#H277"><img src="fm2html-previous.gif">Functional
Description</a><br>
<head>
<title>
TCP/IP Tutorial and Technical Overview
</title>
<body>

<h2><a name="ipng">2.16  IP: The Next Generation (IPng)</a>
</h2>
<a name=spotipng>
<p>The Internet has grown extremely rapidly in recent years, and by December
1994 it comprised over 32,000 networks connecting over 3.8 million computers in
more than 90 countries. Since a 32-bit address field provides for over 4
billion possible addresses, it would seem that the IP addressing scheme is more
than adequate to the task of addressing all of the hosts on the internet since
there appears to be room for a thousand-fold increase before the IP addressing
scheme is completely filled. Unfortunately, this is not the case, for a number
of reasons, including the following:
<ul>
<li>The IP address is divided into a network number and a local part which is
administered separately. Although the address space within a network may be
very sparsely filled, as far as the effective IP address space is concerned, if
a network number is used then all addresses within that network are used.
<li>The address space for networks is structured into Class A, B and C networks
of differing sizes, and the space within each needs to be considered
separately.
<li>The IP addressing model requires that unique network numbers be assigned to
all IP networks whether or not they are actually connected to the Internet.
<li>Growth of TCP/IP usage into new areas could result in a rapid explosion of
the number of required IP addresses. For example, widespread use of TCP/IP for
interconnecting electronic point-of-sale terminals or for cable television
receivers would enormously increase the number of IP hosts.
<li>The current model of IP addressing with a single IP address for each
(non-routing) host might change in the future (see <i>RFC 1681 -- On Many
Addresses per Host</i> <a name=index1011>for</a> a discussion of some potential
drivers for such a change).
</ul>
These factors mean that the address space is much more constrained than our
simple analysis would indicate. This problem is called <i>IP Address
Exhaustion</i><a name=index1012>.</a> Methods of relieving this problem are
already being employed (see the discussion beginning with
<a href="3376c22.html#ipexh">The IP Address Exhaustion Problem</a>) but
eventually, the present IP address space will be exhausted. The Internet
Engineering Task Force (IETF) has a working group on <i>Address Lifetime
Expectations (ALE)</i> with the express purpose of providing estimates of when
exhaustion of the IP will become an intractable problem, and current estimates
(as reported in the ALE working group minutes for December 1994) are that the
IP address space will be exhausted at some point between 2005 and 2011. Before
this happens, a replacement for the current version of IP will be required.
Since there is also the possibility that a change in the usage trends of IP
addresses could bring this forward, a replacement may need to be deployed by
the turn of the century. This replacement is referred to as <i>IP: The Next
Generation (IPng)</i><a name=index1014>.</a> When discussing IPng, the current
version of IP (version 4) is referred to as <i>IPv4</i>. The responsibility for
the decision on the final form of IPng lies with the <i>IPng Directorate</i>.
<a name=index1015>There</a> are a number of other IPng-related working groups:
<i>IPng Requirements (IPNGREQ)</i>, <i>Transition and Co-existence including
Testing (TACIT)</i> and one group for each of the proposed candidates for IPng.
These groups are all temporary and are expected to disband or to be merged with
other working groups in other areas when the IPng definition process has
completed.

<h3><a name="H281">2.16.1  The Requirements for IPng</a>
</h3>
<p>In July 1994, at an IETF meeting in Toronto, the IPng Area Directors of the
IETF presented <i>RFC 1752 - The Recommendation for the IP Next Generation
Protocol</i>.  The recommendation was approved by the IETF in November 1994 and
made a <i>proposed standard</i>.
<p>These events were the culmination of much work and discussion which involved
many interested parties.  In this section we will look at crucial stages in
getting to this point in the development of the IPng standard.
<p>The IPng directorate published <i>RFC 1550 - IP: The Next Generation (IPng)
White Paper Solicitation</i> requesting requirements for IPng. The important
IPng requirements are summarized here:
<ul>
<li>A dramatically larger address space: at least 10(superscript 9) networks,
preferably 10(superscript 12); and at least 10(superscript 12) hosts,
preferably 10(superscript 15). at least one billion networks, preferably 1000
billion; and at least 1000 times as many hosts. This would allow dramatic
increases in IP address usage and at the same time leave the address space
sparsely populated allowing IPng addresses to have more structure than is
possible with IPv4.
<li>IPng should allow encapsulation of its own or other protocols' packets.
<li>IPng should add classes of service to distinguish types of data being
transmitted, such as isochronous traffic like real-time audio and video.
<li>IPng must provide multicast addressing in a form which is more fully
integrated with the rest of the protocol suite than the present implementation.
<li>IPng must provide authentication and encryption.
<li>IPng should preserve the virtues of IPv4: robustness, independence from the
physical network characteristics, high performance, flexible topology,
extensibility, datagram service, globally unique addressing, a built-in control
protocol and freely available standards.
<li>The implementation of IPng must involve a simple transition plan.
<li>IPng must coexist with IPv4.
</ul>

<h3><a name="H282">2.16.2  IPng Candidates</a>
</h3>
<p>There were three main proposals for IPng which are described briefly below:

<h4><a name="H283">2.16.2.1  Common Architecture for the Internet (CATNIP)</a>
</h4>
<p><a name=index1018>CATNIP</a> is a development of an older protocol (TP/IX)
that integrates IPv4, Novell IPX and OSI Connectionless Networking Protocol
(CLNP) and provides a common infrastructure. It is closest in design to CLNP
and emphasizes ease of interoperability with existing implementations of all
three. The CATNIP packet contains all of the information required by any of the
three protocols in a compressed format using a packet header of 16 bytes or
more. CATNIP uses a variable length address. Existing IPv4 addresses are mapped
to 7-byte addresses of which the last 4 bytes are the IPv4 address. Existing
IPv4 hosts would be limited to interoperating with CATNIP hosts with addresses
in this form.
<p>CATNIP is described in <i>RFC 1707 - CATNIP: Common Architecture for the
Internet</i>.

<h4><a name="H284">2.16.2.2  TCP and UDP with Bigger Addresses (TUBA)</a>
</h4>
<p><a name=index1021>TUBA</a> is also based on CLNP; simply put, CLNP replaces
IPv4 in the TCP/IP protocol stack. It emphasises multiprotocol internets.
Transition between IPv4 and IPng is done using a dual stack approach. The
protocol stack has two independent internetwork layers and when attempting to
communicate with another host, a dual stack host queries the Domain Name System
for both the IP address and the <i>Network Service Access Point (NSAP)</i> that
is the CLNP equivalent. <a name=index1022>If</a> the Domain Name System returns
both the IP address and the NSAP, the hosts communicate with CLNP as the
internetwork protocol.
<p>TUBA is described in <i>RFC 1347 - TCP and UDP with Bigger Addresses (TUBA),
A Simple Proposal for Internet Addressing and Routing</i>.
<a name=index1023>See</a> also <i>RFC 1526 -  Assignment of System Identifiers
for TUBA/CLNP Hosts</i> and <i>RFC 1561 - Use of ISO CLNP in TUBA
Environments</i>.

<h4><a name="H285">2.16.2.3  Simple Internet Protocol Plus (SIPP)</a>
</h4>
<p><a name=index1026>SIPP</a> is a combination of the work of three earlier
IETF working groups developing an IPng.
<dl>
<dt>
IP Address Encapsulation (IPAE)
<dd><a name=index1027>IPAE</a> involved extensions to IPv4 to carry longer
addresses, and how the transition between the two would be achieved.
<dt>
Simple Internet Protocol (SIP)
<dd><a name=index1029>SIP</a> was an IPv4 replacement with a simplified IP
header and 64-bit addressing. SIP merged with IPAE taking the SIP header and
the IPAE transition mechanisms.
<dt>
``P'' Internet Protocol (Pip)
<dd><a name=index1031>Pip</a> was a brand new internet protocol designed with a
wide range of advanced features and using variable length addressing. Pip
merged with SIP when it was realized that the best features of Pip could be
used with the SIP 64-bit addressing scheme and the IPAE transition mechanisms.
</dl>
<p>SIPP is an evolutionary development of IPv4. It emphasizes efficiency of
operation over a wide range of network types and ease of interoperability. In
addition to 64-bit addressing it includes a concept of extended addresses by
using a routing option: the effective address length can be any multiple of 64
bits.
<p>SIPP is described in <i>RFC 1710 - Simple Internet Protocol Plus White
Paper</i>.

<h3><a name="ipv6">2.16.3  IP Version 6 (IPv6)</a>
</h3>
<p><a name=index1034>The</a> IPng Directorate concluded that all three of these
proposals (CATNIP, TUBA and SIPP) were insufficient to meet the accepted list
of requirements, but that SIPP, as defined in RFC 1710, came closest. After
some changes to the original proposal, for instance the use of 128-bit
addresses instead of 64-bit ones, the IPng Directorate decided that SIPP was a
suitable base for IPng and that features from the other proposals would be
added to it to fulfill the remaining IPng requirements. The proposed solution
is called <i>IP Version 6 (IPv6)</i>.
<p>The reader should be aware that the definition of IPv6 is still in progress,
and the information presented here is based on Internet-Draft documents.
<a href=3376footnotes.html#footnote6>(6)</a>
<hr><strong>**** Warning ****</strong>
<p>All of the information in Section <a href="3376c216.html#ipv6">IP Version 6
(IPv6)</a> is subject to change and should not be used as reference
information.
<p>The final definition of IPv6 will, it is expected, be published as a series
of Standards Track RFCs.
<hr>
<hr><strong>**** Terminology ****</strong>
IPv6 uses the term <i>packet</i> rather than <i>datagram</i>, but the meaning
is the same, although the formats are different.
<p><a name=index1035>IPv6</a> introduces a new term, <i>node</i>, for a system
running IPv6, that is, a host or a router. <a name=index1038>An</a> IPv6 host
is a node which does not forward IPv6 packets which are not explicitly
addressed to it. A router is, as in IPv4, a node which does forward IP packets
not addressed to it.
<hr>
<p>The basic features of IPv6 as defined at the time of writing are described
in the following sections.

<h4><a name="ipv6hdr">2.16.3.1  The IPv6 Header format</a>
</h4>
<p><a name=index1039>IPv6</a> increases the length of the IP header from 20
bytes to 40 bytes. The IPv6 header contains two 16-byte addresses (source and
destination) preceded by 8 bytes of control information as shown in
<a href="3376c216.html#figipv6hdr">Figure - IPv6 Header</a>. The IPv4 header
(see <a href="3376c23.html#figipv4hdr">Figure - IP Datagram Format</a>) has two
4-byte addresses preceded by 12 bytes of control information and possibly
followed by option data. The reduction of the control information and the
elimination of options in the header are intended to optimize the processing of
the majority of IP datagrams (packets). The infrequently used fields which have
been removed from the header are moved to optional extension headers.
<br><br><a name=figipv6hdr>
<img src="3376f69.gif"></a>
<br><i>Figure: IPv6 Header</i><br><br>
<dl>
<dt>
Vers
<dd>4-bit Internet Protocol version number: 6.
<dt>
Flow Label
<dd>28-bit field. See <a href="3376c216.html#ipv6flw">Flow Labels</a> below.
<dt>
Payload Length
<dd>The length of the packet in bytes (excluding this header) encoded as a
16-bit unsigned integer.  If length is greater than 64KB this field is 0 and an
option header gives the true length.
<dt>
Next Header
<dd><a name=index1040>Indicates</a> the type of header immediately following
this header. This is the same as the protocol number used in IPv4 (see the list
in <a href="3376c23.html#ip">Internet Protocol (IP)</a>). The next header field
is also used to indicate the presence of extension headers, which provide the
mechanism for appending optional information to the IPv6 packet. The following
values are important in addition to those mentioned for IPv4.
<dl>
<dt>
41
<dd>IPv6 Header
<dt>
43
<dd>IPv6 Routing Header
<dt>
44
<dd>IPv6 Fragment Header
<dt>
51
<dd>IPv6 Authentication Header
<dt>
?
<dd>IPv6 End-to-End Options Header
<dt>
?
<dd>IPv6 ICMP Packet
</dl>
The values, except for the last two (which were undecided at the time of
writing) are given in <i>STD 2 - Assigned Internet Numbers</i>, although the
current edition of STD 2 at the time of writing (RFC 1700) mentions either SIP
or SIPP as the protocol. <a name=index1041>As</a> noted above, IPv6 is a
development of these two protocols.
<p>The different types of extension header are discussed briefly below.
<dt>
Hop Limit
<dd><a name=index1042>This</a> is the IPv4 TTL field but now it is measured in
hops and not seconds. It was changed for two reasons:
<ul>
<li>IP normally forwards datagrams at faster than one hop per second and the
TTL field is always decremented on each hop, so in practice it is measured in
hops and not seconds.
<li>Many IP implementations do not expire outstanding datagrams on the basis of
elapsed time.
</ul>
<dt>
Source Address
<dd>A 128-bit address. IPv6 addresses are discussed in
<a href="3376c216.html#ipv6adr">IPv6 Addresses</a>.
<dt>
Destination Address
<dd>A 128-bit address. IPv6 addresses are discussed in
<a href="3376c216.html#ipv6adr">IPv6 Addresses</a>.
</dl>
<p>A comparison between the IPv4 and IPv6 header formats will show that a
number of IPv4 header fields have no direct equivalents in the IPv6 header.
<dl>
<dt>
Type of Service
<dd>Type of service issues in IPv6 will be handled using the <i>flow</i>
concept, described in <a href="3376c216.html#ipv6flw">Flow Labels</a>.
<dt>
Identification, Fragmentation Flags and Fragment Offset
<dd>Fragmented packets have an extension header rather than fragmentation
information in the IPv6 header. This reduces the size of the basic IPv6 header.
Since higher-level protocols, particularly TCP, tend to avoid fragmentation of
datagrams, this reduces the IPv6 header overhead for the normal case. As noted
below, IPv6 does not fragment packets en route to their destinations, only at
the source.
<dt>
Header Checksum
<dd><a name=index1046>Because</a> transport protocols implement checksums, and
because IPv6 includes an optional authentication header which can also be used
to ensure integrity, IPv6 does <i>not</i> provide checksum monitoring of IP
packets.
<p>Both TCP and UDP include a pseudo-IP header in the checksums they use, so in
these cases, the IP header in IPv4 is being checked twice.
<p>TCP and UDP, and any other protocols using the same checksum mechanisms
running over IPv6 will continue to use a pseudo-IP header although, obviously,
the format of the pseudo-IPv6 header will be different from the pseudo-IPv4
header. ICMP and IGMP and any other protocols which do not use a pseudo-IP
header over IPv4 will use a pseudo-IPv6 header in their checksums.
<dt>
Options
<dd>All optional values associated with IPv6 packets are contained in extension
headers ensuring that the basic IP header is always the same size.
</dl>

<h4><a name="ipv6siz">2.16.3.2  Packet Sizes</a>
</h4>
<p>All IPv6 nodes are expected to dynamically determine the maximum
transmission unit (MTU) supported by all links along a path (as described in
<i>RFC 1191 - Path MTU Discovery</i>) and source nodes will only send packets
which do not exceed the Path MTU. <a name=index1048>IPv6</a> routers will
therefore not have to fragment packets in the middle of multihop routes and
allow much more efficient use of paths which traverse diverse physical
transmission media. It is currently proposed that IPv6 require that every link
supports an MTU of 576 bytes, but this value, like all other parts of the IPv6
specification at the time of writing, is subject to change.

<h4><a name="ipv6ext">2.16.3.3  Extension Headers</a>
</h4>
<p><a name=index1050>Extension</a> headers are placed between the IPv6 packet
header and the data intended for the higher level protocol. They are counted as
part of the payload length. Each header has an 8-bit <i>Next Header field</i>
like that in the IPv6 header which identifies the type of the following header.
All extensions defined at the time of writing have the Next Header field as the
first byte of the header. The length of each header, which is always a multiple
of 8 bytes, is encoded later in the header in a format specific to that header
type. There are a limited number of IPv6 extension headers, any or all of which
may be present once (and once only) in the IPv6 packet. IPv6 nodes which
originate packets are required to place extension headers in a specific order
although IPv6 nodes which receive packets are not required to verify that this
is the case. The different types of extension header, as defined at the time of
writing, are discussed briefly below. When the Next Header field contains a
value other than one for an extension headers, this indicates the end of the
IPv6 headers and the start of the higher-level protocol data.
<p>IPv6 allows for encapsulation of IPv6 within IPv6 (``tunneling'').
<a name=index1051>This</a> is done with a Next Header value of 41 (IPv6). The
encapsulated IPv6 packet may have its own extension headers. Because the size
of a packet is calculated by the originating node to match the Path MTU, IPv6
routers should not add extension headers to a packet but instead should
encapsulate the received packet within an IPv6 packet of their own making
(which may be fragmented if necessary).
<p>With the exception of the Hop-by-Hop header (which must immediately follow
the IP header if present), extension headers are not processed by any route on
the packet's path except the final one. Note that, as in IPv4, when a source
route is included, the packet's destination IP address is actually the next
node in the source route, and not the true destination, so this statement
remains true but the word path means the path to the next destination listed in
the source route.
<p>IPv6 uses a common format called the <i>Type-Length-Value (TLV)</i> format
for variable length fields which are found in the Hop-by-Hop and End-to-End
option headers. <a name=index1052>The</a> option has a 2-byte header followed
by the option data.
<br><br><a name=fig>
<img src="3376f70.gif"></a>
<br><i>Figure: IPv6 Type-Length-Value Option Format</i><br><br>
<dl>
<dt>
Type
<dd>The type of the option. The option types all have a common format:
<br><br><img src="3376f71.gif"><br><br>
<dl>
<dt>
xx
<dd>A 2-bit number indicating how an IPv6 node which does not recognize the
option should treat it.
<dl>
<dt>
0
<dd>skip the option and continue
<dt>
1
<dd>discard the packet quietly
<dt>
2
<dd>discard the packet and inform the sender with an ICMP Unrecognized Type
message
<dt>
3
<dd>discard the packet and inform the sender with an ICMP Unrecognized Type
message unless the destination address is a multicast address
</dl>
<dt>
y
<dd>This bit has a specific meaning only for the Hop-by-Hop header. If set, it
indicates that the value of the option may change en route and therefore it
should be excluded from any integrity calculations performed on the packet.
Since only hop-by-hop headers are examined by intermediate routers, only
hop-by-hop options can be validly changed en route.
<dt>
zzzzz
<dd>The remaining bits define the option.
</dl>
<dt>
Length
<dd>The length of the option value field in bytes.
<dt>
Value
<dd>The value of the option. This is dependent on the type.
</dl>
<p>To optimize the performance of IPv6 implementations, individual options are
aligned so that multi-byte values are positioned on their natural boundaries.
In many cases, this will result in the option headers being longer than
otherwise necessary, but should allow nodes to process datagrams more quickly.
To allow this alignment, all IPv6 implementations must recognize two padding
options:
<dl>
<dt>
Pad1
<dd>A X'00' byte used for padding a single byte. Longer padding sequences
should be done with the PadN option.
<dt>
PadN
<dd>An option in the TLV format described above. Its value is X'01'. The length
byte gives the number of bytes of padding after the minimum two that are
required.
</dl>
<p>The different extension headers are described (in the order in which they
must be placed in the IPv6 packet) in the following sections.

<h5><a name="ipv6hbh">Hop-by-Hop Header</a>
</h5>
<a name=spotipv6hbh>
<p><a name=index1054>A</a> Hop-by-Hop header contains options which must be
examined by every node the packet traverses as well as the destination node. It
must immediately follow the IPv6 header if present and is identified by the
special value 0 in the Next Header field of the IPv6 header. This value is not
a Protocol number but a special case to identify this unique type of extension
header and the value 0 remains reserved in STD 2.
<p>Initially, no Hop-by-Hop options (other than the pad options) are defined.

<h5><a name="ipv6rou">Routing Header</a>
</h5>
<p><a name=index1055>The</a> routing header is identified by the value 43 in
the preceding Next Header field. It has its next header field as the first byte
and a single byte routing type as the second. The only type defined initially
is Loose Source Routing, which operates in the same way as IPv4.
<br><br><a name=fig>
<img src="3376f72.gif"></a>
<br><i>Figure: IPv6 Loose Source Routing Header</i><br><br>
<dl>
<dt>
Next Header
<dd>The type of next header after this one.
<dt>
00
<dd>Indicates loose source routing.
<dt>
#Addresses
<dd>Indicates the number of entries as an 8-bit unsigned integer. Compare this
with IPv4 which uses a length byte to calculate the number of entries in the
option field.
<dt>
Next Address
<dd>Index of the next address as an 8-bit unsigned integer to be processed
(initialized to 0 by the originator) integer. Compare this with IPv4, which
uses a pointer offset from the start of the source routing option.
<dt>
reserved
<dd>Initialized to zero for transmission and ignored on reception. This ensures
that the header is a multiple of 16 bytes long. It does not ensure that
addresses fall on 16-byte boundaries.  IPv6 does not take account of alignment
of fields longer than 8 bytes.
<dt>
Address n
<dd>A series of 16-byte IPv6 addresses which comprise the source route.
</dl>

<h5><a name="ipv6frg">Fragment Header</a>
</h5>
<p>The fragment header is identified by the value 44 in the preceding Next
Header field.
<br><br><a name=fig>
<img src="3376f73.gif"></a>
<br><i>Figure: IPv6 Fragment Header</i><br><br>
<dl>
<dt>
<a name=index1056>Next</a> Header
<dd>The type of next header after this one.
<dt>
reserved
<dd>Initialized to zero for transmission and ignored on reception.
<dt>
Fragment Offset
<dd>A 13-bit unsigned integer giving the offset of the following payload
relative to the beginning of the original unfragmented payload in 8-byte units.
The field is a 13-bit count of 8-byte units instead of a 16-bit byte count
because the payload is always fragmented on 8-byte boundaries, so the low order
three bits of the byte offset are always zero.
<dt>
00
<dd>Initialized to zero for transmission and ignored on reception.
<dt>
M
<dd>More flag. If set it indicates that this is not the last fragment.
<dt>
Identification
<dd>Used to identify packets which are fragments of the same datagram. This is
very similar to the IPv4 Identifier field, but it is twice as wide.
</dl>

<h5><a name="ipv6aut">Authentication Header</a>
</h5>
<p><a name=index1057>The</a> authentication header is identified by the value
51 in the preceding Next Header field.
<br><br><a name=fig>
<img src="3376f74.gif"></a>
<br><i>Figure: IPv6 Fragment Header</i><br><br>
<dl>
<dt>
Next Header
<dd>The type of next header after this one.
<dt>
Length
<dd>The length of the authentication data in 8-byte units.
<dt>
reserved
<dd>Initialized to zero for transmission and ignored on reception.
<dt>
Security Association ID
<dd>Used to identify the recipient (with the destination IP address).
<dt>
Authentication Data
<dd>Dependent on the authentication algorithm in use. All IPv6 nodes will
support a minimum authentication algorithm.
</dl>

<h5><a name="ipv6e2e">End-to-End Header</a>
</h5>
<p><a name=index1058>This</a> has the same format as the Hop-by-Hop header, but
it is only examined by the target node. Since it follows the routing header
this is true regardless of any routing options which may be in effect. Again,
only the padding options are initially specified. The value for the preceding
Next Header field has not yet been defined.

<h4><a name="ipv6adr">2.16.3.4  IPv6 Addresses</a>
</h4>
<p><a name=index1060>IPv6</a> provides for an address of 128 bits in length.
Unlike IPv4 which has a strictly codified form based on the address class
indicated by the high-order bits of the address, IPv6 addresses are not
structured in this way. Instead, they are designed to be used with Classless
InterDomain Routing (CIDR) (see <a href="3376c22.html#cidr">Classless
Inter-Domain Routing (CIDR)</a>). The IPv6 address space is sufficiently large
that it can encompass a wide range of existing and proposed address spaces. In
keeping with the CIDR approach, the leading part of the IPv6 address, for
example the first byte, would indicate the type of address. Such types would
include a mapping of the current IPv4 address space to IPv6, OSI NSAPs, Novell
IPX addresses and so on. Furthermore, the IPv6 routing header allows IP to
encapsulate arbitrary addressing information in each packet. This could be used
to extend the IPv6 scheme to address hypothetical systems which cannot be
mapped to the IP address space. Given the length of the IPv6 address field, it
is unlikely that this will be necessary in the near future.

<h4><a name="ipv6flw">2.16.3.5  Flow Labels</a>
</h4>
<p><a name=index1062>IPv6</a> introduces the concept of a <i>flow</i> which is
a series of related packets from a source to a destination which requires a
particular type of handling by the intervening routers, for example
``real-time'' service. The nature of that handling can either be conveyed by
options attached to the datagrams (that is, by using the IPv6 Hop-by-Hop
options header) or by a separate protocol.
<p><a name=index1063>Each</a> IPv6 packet contains a flow label which is a
28-bit field:
<br><br><a name=fig>
<img src="3376f75.gif"></a>
<br><i>Figure: IPv6 Flow Label</i><br><br>
<dl>
<dt>
<a name=index1064>x</a>
<dd>A flag bit indicating whether the traffic is flow-controlled. If set, the
traffic is not flow-controlled (there is no feedback from the recipients)
otherwise there is flow control (for example the packets contain TCP segments).
<dt>
Class
<dd>A 3-bit number identifying the traffic type. Although the protocol used to
control the flow may redefine the values, the following recommended values are
defined for flow-controlled traffic:
<dl>
<dt>
0
<dd>uncharacterized traffic
<dt>
1
<dd>``filler'' traffic
<dt>
2
<dd>unattended data transfer, such as E-mail
<dt>
3
<dd>reserved
<dt>
4
<dd>attended bulk transfer, such as FTP
<dt>
5
<dd>reserved
<dt>
6
<dd>interactive traffic, such as TELNET
<dt>
7
<dd>internet control traffic, such as routing protocols
</dl>
For non-flow controlled traffic, the class value is used as a priority when
there is a problem. The lower the class value, the less concerned the sender is
that the packet reaches its destination. For example, with a suitable protocol
for high fidelity real-time video transport, loss of some packets may have a
negligible effect on the viewer's perception compared with a backlog of packets
or the arrival of packets in the wrong order.
<dt>
Flow ID
<dd>A unique pseudo-random 24-bit number assigned to a flow by the source node.
The value of zero is used for traffic which is not assigned to a flow. The
randomness is needed to allow routers to employ a sequence of bits from the
flow ID as a hash key.
</dl>

<h4><a name="ipv6sit">2.16.3.6  Simple Internet Transition (SIT)</a>
</h4>
<p><a name=index1065>The</a> techniques to be employed to convert the Internet
from IPv4 to IPv6 are collectively termed <i>Simple Internet Transition
(SIT)</i>. The emphasis in SIT is the ease of the process from the network user
or operator's point of view. Compatibility features ensure investment
protection for current IPv4 users, interoperability features ensure that the
transition is gradual and does not impact the Internet's functionality. The
transition employs the following techniques:
<ul>
<li>Dual-stack IP implementations for hosts and routers which must interoperate
between IPv4 and IPv6.
<li>Imbedding of IPv4 addresses in IPv6 addresses, IPv6 hosts will be assigned
addresses which are interoperable with IPv4, and IPv4 host addresses will be
mapped to IPv6.
<li>An IPv6-over-IPv4 tunneling mechanism.
The final technique is intended for use when the implementation of IPv6 is well
advanced. It allows the implementation of IPv6-only nodes. Such nodes must
exist within fully IPv6-capable networks.
<li>IPv4/IPv6 header translation by routers between IPv4 and IPv6 networks.
</ul>
The techniques are also adaptable to other protocols, notably CLNP and IPX
which have similar internetwork layer semantics and which have addressing
schemes which can be mapped easily to a part of the IPv6 address space.
<p>The transition model envisages different organizations migrating
independently and in two phases. The first phase is a transition to a dual
IPv6/IPv4 infrastructure. The second, which is <i>not</i> mandatory, is to an
IPv6-only infrastructure. The second stage for any given site is only complete
when that site no longer requires interoperability with IPv4. When this is
complete, the restrictions imposed by the transition are removed.
<p>The first stage is the easy one of the two, since all nodes are IPv4
capable. The second stage which involves IPv6-only areas in a network, requires
more effort, particularly in the planning and deployment of routers which will
perform the necessary header translation for IPv6-only nodes to interoperate
with IPv4-only nodes.

<h5><a name="H306">Deployment of IPv6/IPv4 nodes</a>
</h5>
<p>This involves the replacement of IPv4-only software with IPv6/IPv4 capable
software. This should happen as part of normal product release cycles, and
existing IPv4 nodes would continue to run in ``IPv4-compatibility'' mode.
<p>Conceptually, the dual stack model envisages a doubling-up of the protocols
in the internetwork layer only. However, related changes are obviously needed
in all transport-layer protocols to operate using either stack, and possibly in
applications if they are to exploit IPv6 capabilities, such as longer
addresses.

<h5><a name="H307">IPv4/IPv6 Addressing</a>
</h5>
<p><b><a name=index1067>Notation</a>:</b> IPv6 addresses are represented as a
sequence of 4 hexadecimal digits (that is, 16-bit groups) separated by colons.
For brevity, the sequence 0000 is contracted to 0. IPv6 addresses which are to
be mapped to IPv4 are best represented as a 96-bit IPv6 prefix in a colon
delimited form followed by a 32-bit IPv4 address in dotted decimal, for example
0:0:0:0:0:ffff:9.180.214.114
<p>Three types of IPv6 address are defined:
<dl>
<dt>
IPv4-compatible IPv6 address
<dd><a name=index1069>An</a> address indicating an IPv6-capable node which has
an address that can be mapped directly and uniquely to the IPv4 address space.
It has the IP prefix 0:0:0:0:0:ffff. For example, 0:0:0:0:0:ffff:9.180.214.114
<dt>
IPv4-mapped IPv6 address
<dd><a name=index1070>An</a> IPv6 address indicating an IPv4-only node. It has
the IP prefix 0:0:0:0:0:0. For example, 0:0:0:0:0:0:9.180.214.114
It is important to realize that IPv4-compatible and IPv4-mapped addresses use
the same IPv4 address space.  The prefix only indicates whether or note the
node is IPv6-capable.
<dt>
IPv6-only address
<dd><a name=index1071>An</a> IPv6 address indicating an IPv6-capable node where
the low-order 32 bits do not necessarily contain an IPv4 address. The
high-order 96 bits are something other than 0:0:0:0:0:ffff or 0:0:0:0:0:0.
</dl>
<p>A new type of record is defined for the Domain Name System (DNS). The AAAA
record indicates an IPv6 address. The records found in the DNS for a node
depend on which protocols it is running.
<ul>
<li>IPv4-only nodes have only A records containing IPv4 addresses in the DNS.
This simplifies DNS administration and means that the default behavior is the
compatible one: IPv6 nodes interpret the contents of the pre-IPv6 DNS as
containing only IPv4 nodes. An IPv6-node can obtain the IPv6 address of any
IPv4-only node in the DNS by prefixing it with the 96-bit prefix 0:0:0:0:0:0.
<li>IPv6-capable nodes which can interoperate with IPv4-only nodes have AAAA
records containing IPv4-compatible IPv6 addresses and A records containing the
equivalent IPv4 addresses.
<li>IPv6-capable nodes which cannot interoperate with IPv4-only nodes have only
AAAA records containing IPv6-only addresses.
</ul>
<p>Because IPv6/IPv4 nodes make decisions about which protocols to use based on
the type of IPv6-address that a destination has, the incorporation of AAAA
records in the DNS is a prerequisite to using the DNS with IPv6. This does not
imply that name servers must use an  IPv6-capable protocol stack, just that
they support an additional record type.

<h5><a name="H308">Interoperability Summary</a>
</h5>
<p>Whether two nodes can interoperate depends upon their capabilities and their
addresses:
<ul>
<li>An IPv6-capable node with an IPv4-compatible address can interoperate
directly with all other nodes.
<li>An IPv6-only node with an IPv4-compatible address can interoperate with all
other nodes. However, it requires a router to translate IPv6 headers to IPv4
headers and vice versa in order to interoperate with IPv4 nodes.
<li>An IPv6-capable node with an IPv6-only address cannot interoperate with
IPv4 nodes.
<li>An IPv4-only node can directly interoperate with IPv6/IPv4 nodes which have
IPv4-compatible addresses.
<li>An IPv4-only node can interoperate with IPv6-only nodes which have
IPv4-compatible addresses. However, it requires a router to translate IPv4
headers to IPv6 headers and vice versa.
<li>An IPv4-only node cannot interoperate with IPv6-capable nodes which have
IPv6-only addresses.
</ul>

<h5><a name="H309">Topological Model</a>
</h5>
<p>It is possible to divide the entire routing topology of the Internet into
areas in such a way that every area falls into at least one of these two types:
<dl>
<dt>
IPv4-complete
<dd><a name=index1072>Every</a> subnet in the area has at least one IPv4-router
attached.
<dt>
IPv6-complete
<dd><a name=index1073>Every</a> subnet in the area has at least one IPv6-router
attached.
</dl>
It is possible for areas to be both IPv4- and IPv6-complete, but the model is
simpler if such areas are treated as one or the other. We use the following
rules for the deployment of non dual-stack nodes:
<ul>
<li>IPv4-only nodes may not be deployed in IPv6-complete areas.
<li>IPv6-only nodes may not be deployed in IPv6-complete areas.
<li>All routers connecting IPv4-complete areas to IPv6-complete areas must
translate IPv4 headers destined for the IPv6-complete area into IPv6 headers,
and vice versa.
</ul>
<p><b>Note:</b> An IPv4-complete area does not mean that no IPv6 routing can be
used in the area, just that IPv4 routing is used throughout the entire area.
The converse is true of IPv6-complete areas.
<p>As noted above, the deployment of header-translating routers is part of the
second phase of the transition. Therefore, IPv6-complete areas are unlikely to
appear in most organizations immediately. The drivers for the introduction of
IPv6-complete areas are likely to be requirements for new facilities which
require IPv6, or exhaustion of the IPv4 address space. Which of these is seen
as more important will vary between organizations. For example, commercial
organizations with large, long-established internal IPv4 networks are unlikely
to be driven by the problem of IP address exhaustion unless they also have a
problem with address space within their own networks. They will, however, be
likely to invest in IPv6 deployment if new business-critical applications
require facilities which are only available on IPv6 or if they require
connectivity to other organizations who are using IPv6-only addresses.

<h5><a name="H310">IPv6-over-IPv4 Tunneling</a>
</h5>
<p><a name=index1074>IPv6</a> packets are tunnelled over IPv4 very simply; the
IPv6 packet is encapsulated in an IPv4 datagram (which may be fragmented).
<p>There are two kinds of tunneling of IPv6 packets over IPv4 networks:
automatic and configured.

<h5><a name="H311">Automatic Tunneling</a>
</h5>
<p><a name=index1075>As</a> the name implies, automatic tunneling is done
whenever it is needed. The decision is made by an IPv6/IPv4 host which has a
packet to send across an IPv4-complete area, and it follows the following
rules:
<ul>
<li>If the destination is an IPv4-mapped address, send the packet using IPv4
because the recipient is not IPv6-capable.
Otherwise:
<li>If the destination is on the same subnet, send it using IPv6 because the
recipient is IPv6-capable.
<li>If the destination is not on the same subnet but there is at least one
default router on the subnet which is IPv6-capable, or there is a route
configured to an IPv6 router for that destination, then send it to that router
using IPv6.
Otherwise:
<li>If the address is an IPv4-compatible address, send the packet using
automatic IPv6-over-IPv4 tunnelling.
Otherwise:
<li>The destination is a node with an IPv6-only address which is connected via
an IPv4-complete area which is not also IPv6-complete and the destination is
therefore unreachable.
</ul>
<p><b>Note:</b> The IP address must be IPv4-compatible for tunneling to be
used. IPv6-only addresses cannot be tunneled to because they cannot be
addressed using IPv4. Packets from IPv6/IPv4 nodes to IPv4-mapped addresses are
not tunnelled to because they refer to IPv4-only nodes.
<p>The rules listed above emphasize the use of an IPv6 router in preference to
a tunnel for three reasons:
<ul>
<li>There is less overhead because there is no encapsulating IPv4 header.
<li>IPv6-only features are available.
<li>The IPv6 routing topology will be used when it is deployed in preference to
the pre-existing IPv4 topology.
</ul>
<p>A node does not need to know whether it is attached to an IPv6-complete or
an IPv4-complete area: it will always use an IPv6-router if one is configured
on its subnet and will use tunneling if one is not (in which case it can infer
that it is attached to an IPv4-complete area).
<p>Automatic Tunneling may be either host-to-host, or it may be router-to-host.
A source host will send an IPv6 packet to an IPv6 router if possible, but that
router may not be able to do the same, and will have to perform automatic
tunneling itself. Because of the preference for the use of IPv6 routers rather
than tunneling, the tunnel will always be as ``short'' as possible. However,
the tunnel will always extend all of the way to the destination host: because
IPv6 uses the same hop-by-hop routing paradigm, a host cannot determine if the
packet will eventually emerge into an IPv6-complete area before it reaches the
destination host. In order to use a tunnel which does not extend all of the way
to the recipient, configured tunneling must be used. There is one exception to
this rule: as described in <a href="3376c216.html#ipv6tht">Header
Translation</a>, all tunnels terminate at routers which perform header
translation.
<p>The mechanism used for automatic tunneling is very simple.
<ul>
<li>The encapsulating IPv4 datagram uses the low-order 32 bits of the IPv6
source and destination addresses to create the equivalent IPv4 addresses and
sets the protocol number to 41 (IPv6).
<li>The receiving node's network interface layer identifies the incoming
packets (or packets if the IPv4 datagram was fragmented) as belonging to IPv4
and passes them upwards to the IPv4 part of the dual IPv6/IPv4 internetwork
layer.
<li>The IPv4 layer then receives the datagram in the normal way, re-assembling
fragments if necessary, notes the protocol number of 41, then removes the IPv4
header and passes the original IPv6 packet ``sideways'' to the IPv6 part of the
internetwork layer.
<li>The IPv6 code then processes the original packet as normal. Since the
destination IPv6 address in the packet is the IPv6 address of the node (an
IPv4-compatible address matching the IPv4 address used in the encapsulating
IPv4 datagram) the packet is at its final destination. IPv6 then processes any
extension headers as normal and then passes the packet's remaining payload to
the next protocol listed in the last IPv6 header.
</ul>
<p>With one exception, described in <a href="3376c216.html#ipv6tht">Header
Translation</a>, intermediate IPv6/IPv4 routers never examine or process the
contents of an encapsulated IPv6 packet. The IPv4 datagram is treated in
exactly the same way as other IPv4 datagrams forwarded by an IPv6/IPv4 router.

<h5><a name="H312">Configured Tunneling</a>
</h5>
<p><a name=index1076>Configured</a> tunneling is used for host-router or
router-router tunneling of IPv6-over-IPv4. The sending host or the forwarding
router is configured so that the route as well as having a next hop also has a
``tunnel end'' address (which is always an IPv4-compatible address because it
must be an IPv6/IPv4 host which is reachable from an IP-complete area). The
process of encapsulation is the same as for automatic tunnelling except that
the IPv4 destination address is not derived from the low-order 32 bits of the
IPv6 destination address, but from the low-order 32 bits of the tunnel end.
When the router at the end of the tunnel receives the IPv4 datagram, it
processes it in exactly the same way as a node at the end of an automatic
tunnel. When the original IPv6 packet is passed to the IPv6 layer in the
router, it recognizes that it is not the destination, and the router forwards
the packet on to the final destination as it would for any other IPv6 packet.
<p>It is, of course, possible that after emerging from the tunnel, the IPv6
packet is tunnelled again by another router.

<h5><a name="ipv6tht">Header Translation</a>
</h5>
<p><a name=index1077>Header</a> translation is required for IPv6-only nodes to
interoperate with IPv4-only nodes. Because there is no requirement for any node
to be IPv6-only, header translation is regarded as an optional part of SIT.
Header translation is performed by IPv6/IPv4 routers on the boundaries between
IPv6-complete areas and IPv4-complete areas. Traffic crossing such a boundary
can be categorized in two ways. First, traffic is either:
<dl>
<dt>
IPv4
<dd>Traffic from an IPv4-complete area entering an IPv6-complete area
or
<dt>
IPv6
<dd>Traffic from an IPv6-complete area entering an IPv4-complete area
Secondly, each of these types may be described as either:
<dt>
Terminating
<dd>Addressed to a node within the area
or
<dt>
Transit
<dd>Addressed to a node outside the area
</dl>
<p>Routers translating between IPv4 and IPv6 must, in addition to correctly
mapping between the the fields in the two headers, select the correct form of
IP addresses to use:
<ul>
<li>IPv4 addresses are obtained by taking the low-order 32 bits of the IP
address. If either the source or the destination IPv6 address is IPv6 only, the
header cannot be translated.
<li>IPv6 source addresses are created by adding the 96-bit prefix 0:0:0:0:0:0
to the IPv4 address to generate an IPv4-mapped IPv6 address.
<li>IPv6 destination addresses are created by adding the 96-bit prefix
0:0:0:0:0:ffff to the IPv4 address to generate an IPv4-compatible IPv6 address
for terminating traffic or the 96-bit prefix 0:0:0:0:0:0 generate an
IPv4-mapped IPv6 address for transit traffic. Therefore, Header translators
must know the extent of their attached IP-complete area.
<a href=3376footnotes.html#footnote7>(7)</a>
</ul>
<p>There is one special case: tunnelled IPv6 traffic, that is, IPv6 packets
encapsulated in IPv4 datagrams. If header translators treated tunnelled IPv6
traffic in the same way as other IPv4 traffic, the result would be an IPv6
packet encapsulated in another IPv6 packet. Therefore, header translators
inspect the protocol number of an IPv4 datagram, and if it is 41 (IPv6) they
``decapsulate'' the packet rather than translate the IPv4 header. In effect,
header translators always terminate tunnels.
<p>Because of this effect, it is not possible, in general, for an IPv6/IPv4
node to send a packet to an IPv6-capable node with an IPv6-only address by
using a configured tunnel to an IPv6/IPv4 router in the same IPv6-complete area
as the target destination. If this were done, the tunnel could intersect a
transit IPv6-complete area and the packet would be decapsulated, terminating
the tunnel. The raw IPv6 packet could not then cross an IPv4-complete area
because of its IPv6-only destination address.
<p>In order for an IPv6/IPv4 node to send a packet to an IPv6-only address via
an IPv4-capable router in the same IPv6-complete area as the target
destination, the packet must contain a IPv6 source route consisting of the
IPv4-capable router and the IPv6-only destination. This packet has an
IPv4-compatible destination address until it reaches the target IPv6-complete
area, so it can be safely tunneled through IPv4 regardless of the topology.

<h5><a name="ipv6sym">Symmetry of the SIT model</a>
</h5>
<p>Although the topological model used by SIT is symmetrical, as is its
classification of nodes as IPv4-only, IPv6-only and IPv6/IPv4, other aspects of
the scheme are not symmetrical:
<ul>
<li>Although all IPv4 addresses have an IPv6 equivalent (IPv4-mapped or
IPv4-compatible), the reverse is not true. There are IPv6-only addresses and
hosts with these addresses cannot interoperate with IPv4.
<li>IPv6/IPv4 hosts will use IPv6 in preference to IPv4 if possible.
<li>SIT does not define a mechanism for IPv4-over-IPv6 tunnelling.
</ul>

<p><a href="./3376fm.html"><img src="fm2html-toc.gif">Table of Contents</a>  <a href="3376c217.html#H316"><img src="fm2html-next.gif">Summary</a><br>
</html>
