<!-- output file generated by BM Utilities -->
<html>

<p><a href="./3376fm.html"><img src="fm2html-toc.gif">Table of Contents</a>  <a href="3376c44.html#H478"><img src="fm2html-previous.gif">DOS</a><br>
<head>
<title>
TCP/IP Tutorial and Technical Overview
</title>
<body>

<h2><a name="namesrv">4.5  Domain Name System (DNS)</a>
</h2>
<br><br><a name=fignamser1>
<img src="3376name.gif"></a>
<br><i>Figure: The Domain Name System</i><br><br>
<p>The Domain Name System is a <i>standard protocol</i> with
<a name=index1489>STD</a> number 13. Its status is <i>recommended</i>. It is
described in <a name=index1491>RFC</a> 1034 and RFC 1035. This section explains
the implementation of the Domain Name System, and the implementation of name
servers. See <a href="3376c22.html#dns">Domain Name System</a> for an overview
of the Domain Name System and its relationship to the IP addressing scheme.

<h3><a name="H481">4.5.1  The Distributed Name Space</a>
</h3>
<p><a name=index1493>The</a> Domain Name System uses the concept of a
<i>distributed name space</i>. Symbolic names are grouped into <i>zones of
authority</i>, or more commonly <i>zones</i>. In each of these zones, one or
more hosts has the task of maintaining a database of symbolic names and IP
addresses and providing a server function for clients who wish to translate
between symbolic names and IP addresses. These local <i>name servers</i> are
then (through the internet on which they are connected) logically
interconnected into a hierarchical tree of <i>domains</i>. Each zone contains a
part or a <i>subtree</i> of the hierarchical tree and the names within the zone
are administered independently of names in other zones. Authority over zones in
vested in the name servers. Normally, the name servers which have authority for
a zone will have domain names belonging to that zone, but this is not required.
Where a domain contains a subtree which falls in a different zone, the name
server(s) with authority over the superior domain are said to <i>delegate
authority</i> <a name=index1495>to</a> the name server(s) with authority over
the subdomain. Name servers may also delegate authority to themselves; in this
case, the domain name space is still divided into zones moving down the domain
name tree, but authority for two zones is held by the same server. The division
of the domain name space into zones is accomplished using resource records
stored in the Domain Name System:
<dl>
<dt>
Start of Authority (SOA) Records
<dd>Defines the start of a zone
<dt>
Name Server (NS) Records
<dd>Marks the end of a zone started by an SOA record and points to a name
server having authority for the next zone
</dl>
In this context, the start of a domain is closer to the root of the tree than
the end. At the root, there can be no higher name servers to delegate
authority: authority for the zone encompassing the root of the name space is
vested in a set of <i>root name servers</i><a name=index1496>.</a>
<a href=3376footnotes.html#footnote11>(11)</a>
<p>The results of this scheme are:
<ul>
<li>Rather than having a central server for the database, the work that is
involved in maintaining this database is off-loaded to hosts throughout the
name space.
<li>Authority for creating and changing symbolic host names and responsibility
for maintaining a database for them is delegated to the organization owning the
zone (within the name space) containing those host names.
<li>From the user's standpoint, there is a single database that deals with
these address resolutions.  The user may be aware that the database is
distributed, but generally need not be concerned about this.
</ul>
<p><b>Note:</b> Although domains within the namespace will frequently map in a
logical fashion to networks and subnets within the IP addressing scheme, this
is not a requirement of the Domain Name System.  Consider a router between two
subnets: it has two IP addresses, one for each network adapter, but it would
not normally have two symbolic names.

<h3><a name="dnsrslv">4.5.2  Domain Resolution</a>
</h3>
<p><a name=index1498>Domain</a> resolution is a client/server process. The
client function (called the <i>resolver</i> or <i>name resolver</i>) is
transparent to the user and is called by an application to resolve symbolic
high-level names into real IP-addresses or vice versa. The name server (also
called a <i>domain name server</i>) is a server application providing the
translation between high-level machine names and the IP addresses. The basic
process is shown in <a href="3376c45.html#figdnsfull">Figure - Using a Full
Resolver for Domain Name Resolution</a> and
<a href="3376c45.html#figdnsstub">Figure - Using a Stub Resolver for Domain
Name Resolution</a>. The former shows a program called a <i>full
resolver</i><a name=index1499>,</a> which is a program distinct from the user
program, which forwards all queries to a name server for processing.
<a name=index1500>Responses</a> are cached by the name server for future use,
and often by the name server. The latter shows a <i>stub
resolver</i><a name=index1501>,</a> which is a routine linked with the user
program, which forwards the queries to a name server for processing. Responses
are cached by the name server but not usually by the resolver although this is
implementation dependent. On UNIX, the stub resolver is implemented by two
library routines: <a name=index1503>gethostbyname()</a> and gethostbyaddr() for
converting host names to IP addresses and vice versa. Other platforms have the
same or equivalent routines. Stub resolvers are much more common than full
resolvers.
<br><br><a name=figdnsfull>
<img src="3376f107.gif"></a>
<br><i>Figure: Using a Full Resolver for Domain Name Resolution</i><br><br>
<br><br><a name=figdnsstub>
<img src="3376f108.gif"></a>
<br><i>Figure: Using a Stub Resolver for Domain Name Resolution</i><br><br>

<h4><a name="H486">4.5.2.1  Domain Name Resolver Operation</a>
</h4>
<p><a name=index1504>Domain</a> name queries can be one of two types:
<i>recursive</i> <a name=index1505>or</a> <i>iterative</i>
<a name=index1507>(also</a> termed <i>non-recursive</i>). A flag bit in the
domain name query specifies whether the client desires a recursive query and a
flag bit in the response specifies whether the server supports recursive
queries. The difference between a recursive and an iterative query arises when
the server receives a request for which it cannot supply a complete answer by
itself. A recursive query requests that the server should issue a query itself
to determine the requested information and return the complete answer to the
client. An iterative query means that the name server should return what
information it has available and also a list of additional servers for the
client to contact to complete the query.
<p>Domain name responses can be one of two types: <i>authoritative</i>
<a name=index1508>and</a> <i>non-authoritative</i><a name=index1509>.</a> A
flag bit in the response indicates which type a response is. When a name server
receives a query for a domain in a zone over which it has authority, it returns
all of the requested information in a response with the authoritative answer
flag set. When it receives a query for a domain over which it does not have
authority, its actions depend upon the setting of the recursion desired flag in
the query.
<menu>
<li>If the recursion desired flag is set and the server supports recursive
queries, it will direct its query to another name server. This will either be a
name server with authority for the domain given in the query, or it will be one
of the root name servers. If the second server does not return an authoritative
answer (for example if it has delegated authority to another server) the
process is repeated.
<p>When a server (or a full resolver program) receives a response, it will
cache it to improve the performance of repeat queries.
<a name=index1510>The</a> cache entry is stored for a maximum length of time
specified by the originator in a 32-bit <i>time-to-live (TTL)</i>
<a name=index1511>field</a> contained in the response. 172,800 seconds (two
days) is a typical TTL value.
<li>If the recursion desired flag is not set or the server does not support
recursive queries, it will return whatever information it has in its cache and
also a list of additional name servers to be contacted for authoritative
information.
</menu>

<h4><a name="H487">4.5.2.2  Domain Name Server Operation</a>
</h4>
<p><a name=index1512>Each</a> name server has <i>authority</i> for zero or more
zones. There are three types of name server:
<dl>
<dt>
primary
<dd><a name=index1513>A</a> primary name server loads a zone's information from
disk, and has authority over the zone.
<dt>
secondary
<dd><a name=index1514>A</a> secondary name server has authority for a zone, but
obtains its zone information from a primary server using a process called
<i>zone transfer</i><a name=index1515>.</a> To remain synchronized, the
secondary name servers query the primary on a regular basis (typically every
three hours) and re-execute the zone transfer if the primary has been updated.
A name server can operate as a primary or a secondary name server for multiple
domains, or a primary for some domains and as a secondary for others. A primary
or secondary name server performs all of the functions of a caching only name
server.
<dt>
caching-only
<dd><a name=index1516>A</a> name server that does not have authority for any
zone is called a caching-only name server. A caching-only name server obtains
all of its data from primary or secondary name servers as required. It requires
at least one NS record to point to a name server from which it can initially
obtain information.
</dl>
<p>When a domain is registered with the root and a separate zone of authority
established, the following rules apply:
<ul>
<li>The domain must be registered with the root administrator.
<li>There must be an identified administrator for the domain.
<li>There must be at least two name servers with authority for the zone which
are accessible from outside and inside the domain to ensure no single point of
failure).
</ul>
<p>It is also recommended that name servers which delegate authority also apply
these rules, since the delegating name servers are responsible for the behavior
of name servers under their authority.

<h3><a name="H488">4.5.3  Domain System Resource Records</a>
</h3>
<p><a name=index1517>The</a> Domain Name System's distributed database is
composed of <i>resource records (RRs)</i>. They provide a mapping between
domain names and <i>network objects</i><a name=index1518>.</a> The most common
network objects are the addresses of Internet hosts, but the Domain Name System
is designed to accommodate a wide range of different objects.
<a name=index1520>The</a> general format of a resource record is:
<pre>
 name ttl class type rdata
</pre>
<p>where:
<dl>
<dt>
name
<dd>Is the domain name to be defined. The domain name system is very general in
its rules for the composition of domain names. However, it recommends a syntax
for domain names which will minimize the likelihood of applications which use a
DNS resolver (that is, nearly all TCP/IP applications) from misinterpreting a
domain name. A domain name adhering to this recommended syntax will consist of
a series of labels consisting of alphanumeric characters or hyphens, each label
having a length of between 1 and 63 characters, starting with an alphabetic
character. Each pair of labels is separated by a dot (period) in human readable
form, but not in the form used within DNS messages. Domain names are not
case-sensitive.
<dt>
ttl
<dd><a name=index1521>Is</a> the <i>time-to-live (TTL)</i> time in seconds that
this resource record will be valid in a name server cache. This is stored in
the DNS as an unsigned 32-bit value. 86400 (one day) is a typical value for
records pointing to IP addresses.
<dt>
class
<dd>Identifies the protocol family. Commonly used values are:
<dl>
<dt>
IN
<dd>The Internet system
<dt>
CH
<dd>The Chaos system
</dl>
<dt>
type
<dd>Identifies the type of the resource in this resource record.
<p>The different types are described <a name=index1524>in</a> detail in RFCs
1034, 1035 and 1706. Each type has a name and a value. Commonly used types
include:   <br><br>
<a name=unnamed><img src=3376t18.gif></a><br>
<br><br>
<dt>
Rdata
<dd>The value depends on the type, for example:
<dl>
<dt>
A
<dd>A 32-bit IP address (if the class is IN)
<dt>
CNAME
<dd>A domain name
<dt>
MX
<dd>A 16-bit preference value (low values being preferred) followed by a domain
name.
<dt>
NS
<dd>A host name
<dt>
PTR
<dd>A domain name
</dl>
</dl>

<h3><a name="dnsmsg">4.5.4  Domain Name System Messages</a>
</h3>
<p><a name=index1527>All</a> messages in the Domain Name System protocol use a
single format. This format is shown in
<a href="3376c45.html#figdnsfmt">Figure - DNS Message Format</a>. This frame is
sent by the resolver to the name server. Only the header and the question
section are used to form the query. Replies and/or forwarding of the query use
the same frame, but with more sections filled in (the
answer/authority/additional sections).
<br><br><a name=figdnsfmt>
<img src="3376f109.gif"></a>
<br><i>Figure: DNS Message Format</i><br><br>
<p>

<h4><a name="H492">4.5.4.1  Header Format</a>
</h4>
<p>The header section is always present and has a fixed length of 12 bytes.
The other sections are of variable length.
<dl>
<dt>
ID
<dd>A 16-bit identifier assigned by the program. This identifier is copied in
the corresponding reply from the name server and can be used for
differentiation of responses when multiple queries are outstanding at the same
time.
<dt>
Parameters
<dd>A 16-bit value in the following format:
<br><br><img src="3376f110.gif"><br><br>
<dl>
<dt>
QR
<dd>Flag identifying a query (0) or a response(1)
<dt>
Op code
<dd>4-bit field specifying the kind of query:
<dl>
<dt>
0
<dd>standard query (QUERY)
<dt>
1
<dd>inverse query (IQUERY)
<dt>
2
<dd>server status request (STATUS)
Other values are reserved for future use
</dl>
<dt>
AA
<dd>Authoritative answer flag. If set in a response, this flag specifies that
the responding name server is an authority for the domain name sent in the
query.
<dt>
TC
<dd>Truncation flag. Set if message was longer than permitted on the physical
channel.
<dt>
RD
<dd>Recursion desired flag. This bit signals to the name server that recursive
resolution is asked for. The bit is copied to the response.
<dt>
RA
<dd>Recursion available flag. Indicates whether the name server supports
recursive resolution.
<dt>
zero
<dd>3 bits reserved for future use.  Must be zero.
<dt>
Rcode
<dd>4-bit response code.  Possible values are:
<dl>
<dt>
0
<dd>No error.
<dt>
1
<dd>Format error. The server was unable to interpret the message.
<dt>
2
<dd>Server failure. The message was not processed because of a problem with the
server.
<dt>
3
<dd>Name error. The domain name in the query does not exist.  This is only
valid if the AA bit is set in the response.
<dt>
4
<dd>Not implemented. The requested type of query is not implemented by name
server
<dt>
5
<dd>Refused. The server refuses to respond for policy reasons.
Other values are reserved for future use.
</dl>
</dl>
<dt>
QDcount
<dd>An unsigned 16-bit integer specifying the number of entries in the question
section.
<dt>
ANcount
<dd>An unsigned 16-bit integer specifying the number of RRs in the answer
section.
<dt>
NScount
<dd>An unsigned 16-bit integer specifying the number of name server RRs in the
authority section.
<dt>
ARcount
<dd>An unsigned 16-bit integer specifying the number of RRs in the additional
records section.
</dl>

<h4><a name="H493">4.5.4.2  </a>
</h4>
Question Section
<p>The next section contains the queries for the name server. It contains
QDcount (usually 1) entries, each in the format shown in
<a href="3376c45.html#figdnsfmtq">Figure - DNS Question Format</a>.
<br><br><a name=figdnsfmtq>
<img src="3376f111.gif"></a>
<br><i>Figure: DNS Question Format</i> - All of the fields are byte-aligned.
The alignment of the Type field on a 4-byte boundary is for example purposes
and is not required by the format.<br><br>
<dl>
<dt>
length
<dd>A single byte giving the length of the next label.
<dt>
label
<dd>One element of the domain name (for example ``ibm'' from ral.ibm.com)
characters. The domain name referred to by the question is stored as a series
of these variable length labels, each preceded by a 1-byte length.
<dt>
00
<dd>X'00' indicates the end of the domain name and represents the null label of
the root domain.
<dt>
Type
<dd>2 bytes specifying the type of query. It may have any value from the Type
field in a resource record.
<dt>
Class
<dd>2 bytes specifying the class of the query. For Internet queries, this will
be "IN".
</dl>
For example, the domain name raleigh.ibm.com would be encoded with the
following fields:
<pre>
       X'07'
       "raleigh"
       X'03'
       "ibm"
       X'03'
       "com"
       X'00'
</pre>
Thus the entry in the question section for raleigh.ibm.com would require 21
bytes: 17 to store the domain name and 2 each for the Qtype and Qclass fields.

<h4><a name="H495">4.5.4.3  Answer, Authority and Additional Resource
Sections</a>
</h4>
<p>These three sections contain a variable number of resource records. The
number is specified in the corresponding field of the header. The resource
records are in the format shown in
<a href="3376c45.html#figdnsfmta">Figure - DNS Answer Record Entry Format</a>.
<br><br><a name=figdnsfmta>
<img src="3376f112.gif"></a>
<br><i>Figure: DNS Answer Record Entry Format</i> - All of the fields are
byte-aligned.  The alignment of the Type field on a 4-byte boundary is for
example purposes and is not required by the format.<br><br>
Where the fields before the TTL field have the same meanings as for a question
entry and:
<dl>
<dt>
TTL
<dd>A 32-bit time-to-live value in seconds for the record. This defines how
long it may be regarded as valid.
<dt>
RDlength
<dd>A 16-bit length for the Rdata field.
<dt>
Rdata
<dd>A variable length string whose interpretation depends on the Type field.
</dl>

<h4><a name="H497">4.5.4.4  Message Compression</a>
</h4>
<p><a name=index1528>In</a> order to reduce the message size, a compression
scheme is used to eliminate the repetition of domain names in the various RRs.
Any duplicate domain name or list of labels is replaced with a pointer to the
previous occurrence. The pointer has the form of a 2-byte field:
<br><br><a name=fig>
<img src="3376f113.gif"></a>
<br><br><br>
<ul>
<li>The first 2 bits distinguish the pointer from a normal label, which is
restricted to a 63-byte length plus the length byte ahead of it (which has a
value of &lt;64).
<li>The offset field specifies an offset from the start of the message. A zero
offset specifies the first byte of the ID field in the header.
<li>If compression is used in an Rdata field of an answer, authority or
additional section of the message, the preceding RDlength field contains the
real length after compression is done.
</ul>

<h3><a name="H499">4.5.5  A Simple Scenario</a>
</h3>
<p><a name=index1530>Consider</a> a stand-alone network (no outside
connections), consisting of two physical networks: one has an internet network
address 129.112, the other has a network address 194.33.7, interconnected by an
IP gateway (VM2).
<br><br><a name=fig>
<img src="3376f114.gif"></a>
<br><i>Figure: A Simple Configuration</i> - Two networks connected through an
IP gateway.<br><br>
<p>Let us assign the name server function to VM1. Remember that the domain
hierarchical tree forms a logical tree, completely independent of the physical
configuration. In this simple scenario, there is only one level in the domain
tree. Let's give this configuration the domain name test.example.
<p>The zone data for the name server will then be as shown in
<a href="3376c45.html#figzndata">Figure - Zone Data for the Name Server</a>.
<br><br><a name=figzndata>
<pre>
;note: an SOA record has no TTL field
;
$origin test.example.                                         ;note 1
;
@             IN SOA VM1.test.example. ADM.VM1.test.example.
                    (870611            ;serial number for data
                     1800              ;secondary refreshes every 30 mn
                     300               ;secondary reties every 5 mn
                     604800            ;data expire after 1 week
                     86400)            ;minimum TTL for data is 1 week
;
@       99999 IN NS  VM1.test.example.                        ;note 2
;
VM1     99999 IN A   129.112.1.1                              ;note 3
        99999 IN WKS 129.112.1.1 TCP (SMTP                    ;note 4
                                      FTP
                                      TELNET
                                      NAMESRV)
;
RT1     99999 IN A     129.112.1.2
              IN HINFO IBM RT/PC-AIX                       ;note 5
RT2     99999 IN A     129.112.1.3
              IN HINFO IBM RT/PC-AIX
PC1     99999 IN A     129.112.1.11
PC2     99999 IN A     194.33.7.2
PC3     99999 IN A     194.33.7.3
;
;VM2 is an IP gateway and has 2 different IP addresses
;
VM2     99999 IN A     129.112.1.4
        99999 IN A     194.33.7.1
        99999 IN WKS   129.112.1.4 TCP (SMTP FTP)
              IN HINFO IBM-3090-VM/CMS
;
4.1.112.129.in-addr.arpa.  IN  PTR  VM2                    ;note 6
;
;Some mailboxes
;
central 10    IN MX  VM2.test.example.                     ;note 7 and 8
;
;a second definition for the same mailbox, in case VM2 is down
;
central 20    IN MX  VM1.test.example.
waste   10    IN MX  VM2.test.example.

</pre>
<br><i>Figure: Zone Data for the Name Server</i><br><br>
<p>
<hr><strong>**** <a name=index1533>Notes</a> ****</strong>
<dl>
<dt>
1
<dd>The <tt>$origin</tt> statement sets the @ variable to the zone name
(test.example.). <a name=index1534>Domain</a> names which do not end with a
period are suffixed with the zone name. Fully qualified domain names (those
ending with a period) are unaffected by the zone name.
<dt>
2
<dd>Defines the name server for this zone.
<dt>
3
<dd>Defines the Internet address of the name server for this zone.
<dt>
4
<dd>Specifies well-known services for this host. These are expected to be
always available.
<dt>
5
<dd>Gives information about the host.
<dt>
6
<dd>Used for inverse mapping queries (see <a href="3376c22.html#dnspq">Mapping
IP Addresses to Domain Names - Pointer Queries</a>).
<dt>
7
<dd>Will allow mail to be addressed to user@central.test.example.
<dt>
8
<dd>See <a href="3376c46.html#smtpdom">SMTP and the Domain Name System</a> for
the use of these definitions.
</dl>
<hr>

<h3><a name="H502">4.5.6  Extended Scenario</a>
</h3>
<p>Consider the case where a connection is made to a third network (129.113)
which has an existing name server with authority for that zone.
<br><br><a name=fig>
<img src="3376f115.gif"></a>
<br><i>Figure: Extended Configuration</i> - A third network is connected to the
existing configuration.<br><br>
<p>Let us suppose that the domain name of the other network is tt.ibm.com and
that its name server is located in VM9.
<p>All we have to do is add the address of this name server to our own name
server database, and to reference the other network by its own name server. The
following two lines are all that is needed to do that:
<pre>
tt.ibm.com.        99999  IN NS       VM9.tt.ibm.com.
VM9.tt.ibm.com.    99999  IN A        129.113.1.9
</pre>
This simply indicates that VM9 is the authority for the new network, and that
all queries for that network will be directed to that name server.

<h3><a name="H504">4.5.7  Transport</a>
</h3>
<p><a name=index1535>Domain</a> Name System Messages are transmitted either as
datagrams (UDP) or via stream connection (TCP).

<h5><a name="H505">UDP usage</a>
</h5>
<p>Server port 53 (decimal).
<p>Messages carried by UDP are restricted to 512 bytes. Longer messages are
truncated and the TC bit is set in the header. Since UDP frames can be lost, a
retransmission strategy is required.

<h5><a name="H506">TCP usage</a>
</h5>
<p>Server port 53 (decimal).
<p>In this case, the message is preceded by a 2-byte field indicating the total
message frame length.
<p><i>STD 3 - Host Requirements</i> requires that:
<ul>
<li><a name=index1536>A</a> Domain Name System resolver or server that is
sending a non-zone-transfer query <i>must</i> send a UDP query first.  If the
answer section of the response is truncated and if the requester supports TCP,
it should try the query again using TCP. UDP is preferred over TCP for queries
because UDP queries have much lower overhead, and the use of UDP is essential
for a heavily loaded server. Truncation of messages is rarely a problem given
the current contents of the Domain Name System database, since typically 15
response records can be accommodated in the datagram, but this may change as
new record types are added to the Domain Name System.
<li>TCP must be used for zone transfer activities because the 512-byte limit
for a UDP datagram will always be inadequate for a zone transfer.
<li>Name servers must support both types of transport.
</ul>

<h3><a name="H507">4.5.8  References</a>
</h3>
<p>The following RFCs define the Domain Name System standard and the
information kept in the system:
<ul>
<li><i>RFC 1032 - Domain Administrator's Guide</i>
<li><i>RFC 1033 - Domain Administrator Operations Guide</i>
<li><i>RFC 1034 - Domain Names - Concepts and Facilities</i>
<li><i>RFC 1035 - Domain Names - Implementation and Specification</i>
<li><i>RFC 1101 - DNS Encoding of Networks Names and Other Types</i>
<li><i>RFC 1183 - New DNS RR Definitions</i>
<li><i>RFC 1706 - DNS NSAP Resource Records</i>
</ul>

<h3><a name="H508">4.5.9  DNS Applications</a>
</h3>
<p><a name=index1544>Three</a> common utilities for querying name servers are
provided with many DNS implementations:
<dl>
<dt>
host
<dd><a name=index1546>Obtains</a> an IP address associated with a host name or
a host name associated with an IP address.
<dt>
nslookup
<dd><a name=index1548>Allows</a> you to locate information about network nodes,
examine the contents of a name server database and establish the accessibility
of name servers.
<dt>
dig
<dd><a name=index1550>Allows</a> you to exercise name servers, gather large
volumes of domain name information and execute simple domain name queries. DIG
stands for Domain Internet Groper.
</dl>

<h3><a name="H509">4.5.10  Implementations</a>
</h3>
<p><a name=index1553>All</a> of the IBM TCP/IP platforms use stub resolvers in
each client application. All except OS/400 and DOS include a name server
implementation, which we will discuss in detail in the following sections.

<h4><a name="H510">4.5.10.1  VM</a>
</h4>
<p>TCP/IP for VM allows for the use of a local site tables or the use of the
Domain Name System.
<p>The use of local site tables or the use of the Domain Name System is
specified in the TCPIP DATA file using the NSINTERADDR statement. If this
statement is omitted, then TCP/IP will use a local site table. If this
statement exists, TCP/IP will use the Domain Name System. If the parameter on
the NSINTERADDR statement is the <i>loopback</i> address (127.0.0.1)
<a href=3376footnotes.html#footnote12>(12)</a>then the local name server will
be used.  Otherwise one (or more) more remote name servers specified on the
NSINTERADDR statements will be used. This provides a total of five possible
configurations.

<h5><a name="H512">Using a local site table</a>
</h5>
<p>To use a local site table, omit the NSINTERADDR statement from the TCPIP
DATA file.  Name resolvers need access to a <i>site table</i>
<a name=index1554>to</a> resolve symbolic names. The source for this is the
HOSTS LOCAL file which must be converted into a machine-readable form by
running the MAKESITE utility. MAKESITE generates two files, HOSTS ADDRINFO and
HOSTS SITEINFO, which comprise the site table. The site table is used if no
name server is available, that is, if no name server is specified or if the
specified name server(s) are unavailable. The only exception is SMTP, which
never uses the site tables if it is configured to use a name server.

<h5><a name="H513">Using a remote name server</a>
</h5>
<p>The resolver program obtains the IP addresses of the remote name server(s)
from the NSINTERADRR statement(s) in the TCPIP DATA file. If multiple
NSINTERADDR statements are found, then connections to the remote name servers
are attempted in the order they appear in this configuration file. The number
of times that each connection is tried and the timeout interval for the server
to respond to the UDP datagram containing the query are specified on the
RESOLVERUDPRETRIES and RESOLVERTIMEOUT statements.

<h5><a name="H514">Caching-only name server</a>
</h5>
<p>The name server software is run in a service virtual machine, normally
called NAMESRV. Resolver programs use the loopback address specified on the
NSINTERADDR statement in the TCPIP DATA file. The server does not have any data
available locally, other than a set of resource records specifying the IP
addresses name servers to query for particular domains (and possibly an initial
set of other resource records). However, the server caches data locally so that
subsequent queries for the same domain name can be quickly answered, and it
also provides for recursion if recursive resolution is asked by the client
resolver. The only data required are the IP addresses of the remote server(s).
<p>The name server configuration file name is specified in the PROFILE EXEC on
the NAMESRV 191 minidisk as an argument to the NSMAIN command which starts the
name server. The default is NSMAIN DATA. In this configuration file, the entry:
<pre>
CACHINGONLY fn ft fm
</pre>
specifies the file name of the data file to be used. The information is written
in standard resource record format, for example:
<pre>
PARIS.IBM.COM                        IN NS     VMA.PARIS.IBM.COM
LAHULPE.IBM.COM                      IN NS     MIDVMB.LAHULPE.IBM.COM
 ..                                  IN NS     SRI-NIC.ARPA
SRI-NIC.ARPA                         IN A      10.0.0.51
                                     IN A      26.0.0.73
VMA.PARIS.IBM.COM                    IN A      9.37.17.2
MIDVMB.LAHULPE.IBM.COM               IN A      9.36.1.4
</pre>
This simply means that all queries for domain PARIS.IBM.COM will be forwarded
to VMA.PARIS.IBM.COM, all queries for LAHULPE.IBM.COM to
MIDVMB.LAHULPE.IBM.COM, and all others to the root server SRI-NIC.ARPA.

<h5><a name="H515">Full-function name server</a>
</h5>
<p>The name server software is run in the NAMESRV service virtual machine and
resolver programs use the loopback address. The name server can operate as a
primary and/or a secondary name server. The domain data is stored in an SQL/DS
table.
<p><i>Mail eXchanger (MX)</i> <a name=index1555>records</a> are supported. They
are only used by SMTP ( see <a href="3376c46.html#smtpdom">SMTP and the Domain
Name System</a> for more details about the use of MX records).
<p>The NSMAIN DATA contains PRIMARY and/or SECONDARY statements instead of a
CACHINGONLY statement. An example is shown in
<a href="3376c45.html#fignsmainv">Figure - Sample NSMAIN DATA File for VM</a>.
<br><br><a name=fignsmainv>
<pre>
;***********************************************************
; This file is read by the name server upon initialization.
; The default name of this file is NSMAIN DATA *.
; A different file may be read by suppling a parameter when
; the name server is started... NSMAIN MY FILE B for example.
;
; This file contains the startup parameter values which define
; the name server as authoritative for stn.mlv.fr and
; tst.mlv.fr.   The data for stn.mlv.fr is defined locally,
; whereas the data for  tst.mlv.fr is defined remotely and zone
; transferred to the local name server.
;
; If you are not using SQL, remove all PRIMARY and SECONDARY
; statements and use the CACHINGONLY statement to define a
; database of remote name servers.
;***********************************************************
;
; The PRIMARY and SECONDARY statements are used if you are using an
; SQL database.
;
PRIMARY stn.mlv.fr STN  ; Use authoritative tables STN0 &amp; STN1
SECONDARY tst.mlv.fr TST 152.9.271.2
;                    ; Use authoritative tables TST0 &amp; TST1
;                    ; Transfer domain data for tst.mlv.fr into tables
;                    ; TST0 and TST1 from 152.9.271.2
;
; The CACHINGONLY statement is used to define a caching only name server
; that obtains all records from remote name servers.
;
; CACHINGONLY  NSMAIN CACHE A     ; Sample CACHINGONLY data file
;
;
NEGATIVECACHING                 ; The NS will store negative query answers
STANDARDQUERYCACHE     100      ; The number of Standard queries to cache
INTERMEDIARYQUERYCACHE  50      ; The number of Intermediary queries to cache
INVERSEQUERYCACHE        5      ; The number of Inverse queries to cache
DATABASEQUERYCACHE       5      ; The number of Data Base queries to cache
;
;
LRUTIME                300      ; Time an entry must be in the cache before it
                                ; can be replaced by the LRU algorithm
HOSTNAMECASE         LOWER      ; Host names in the SQL tables are in lower case
DOMAINNAMEPORT          53      ; Listen on port N, default is 53
; UDPONLY                       ; Use UDP only when contacting a remove NS
UDPRETRYINTERVAL         5      ; After N seconds, try next remote NS
; NORECURSION                   ; Prevents NS from performing recursion
MSGNOH                          ; Specifies the NS use CP MSGNOH, not CP MSG
SMSGUSERFILE    VALIDUSR EXEC A ; SMSG userid authorization file
TRACE              QUEUE        ; Display query origination and query name
</pre>
<br><i>Figure: Sample NSMAIN DATA File for VM</i><br><br>

<h5><a name="H517">User Applications</a>
</h5>
<p>VM provides the NSLOOKUP and DIG programs to query name servers. For more
information on these programs, please refer to <i>IBM TCP/IP Version 2 Release
3 for VM: User's Guide</i>.

<h4><a name="H518">4.5.10.2  MVS</a>
</h4>
<p><b>Note:</b> Consult <i>IBM TCP/IP Version 3 Release 1 for MVS:
Customization and Administration Guide</i> for information on the search order
used for TCP/IP data sets.
<p>TCP/IP for MVS supports both local site tables and the Domain Name System.
<p>The use of local site tables or the use of the Domain Name System is
specified in the TCPIP.DATA data set using the NSINTERADDR statement. If this
statement is omitted, TCP/IP will use a local site table. If this statement
exists TCP/IP will use the Domain Name System. If the parameter on the
NSINTERADDR statement is the <i>loopback</i> address (127.0.0.1)
<a href=3376footnotes.html#footnote13>(13)</a>then the local name server will
be used, otherwise one (or more) more remote name servers specified on the
NSINTERADDR statements will be used. This provides a total of five possible
configurations.

<h5><a name="H520">Using a local site table</a>
</h5>
<p>To use a local site table, omit the NSINTERADDR statement from the
TCPIP.DATA data set. Name resolvers need access to a <i>site table</i>
<a name=index1556>to</a> resolve symbolic names. The source for this is the
HOSTS.LOCAL data set, which must be converted into a machine-readable form by
running the MAKESITE utility. MAKESITE generates two data sets, HOSTS.ADDRINFO
and HOSTS.SITEINFO, which comprise the site table. The site table is used if no
name server is available, that is, if no name server is specified or if the
specified name server(s) are unavailable. The only exception is SMTP, which
never uses the site tables if it is configured to use a name server.

<h5><a name="H521">Using a Remote Name Server</a>
</h5>
<p>The resolver program obtains the IP addresses of the remote name server(s)
from the NSINTERADRR statement(s) in the TCPIP.DATA data set. If multiple
NSINTERADDR statements are found then connections to the remote name servers
are attempted in the order they appear in this configuration file. The number
of times that each connection is tried and the timeout interval for the server
to respond to the UDP datagram containing the query are specified on the
RESOLVERUDPRETRIES and RESOLVERTIMEOUT statements.

<h5><a name="H522">Caching-only name server</a>
</h5>
<p>The name server software is run in a separate address space. Resolver
programs use the loopback address specified on the NSINTERADDR statement in the
TCPIP DATA file. The server does not have any data available locally, other
than a set of resource records specifying the IP addresses name servers to
query for particular domains (and possibly an initial set of other resource
records). However, the server caches data locally so that subsequent queries
for the same domain name can be quickly answered, and it also provides for
recursion if recursive resolution is asked by the client resolver. The only
data required are the IP addresses of the remote server(s).
<p>The NSMAIN.DATA configuration data set contains the entry:
<pre>
CACHINGONLY data_set_name
</pre>
which gives the name of the data set containing these IP addresses. The
information is written in standard resource record format, for example:
<pre>
PARIS.IBM.COM                        IN NS     MVSA.PARIS.IBM.COM
LAHULPE.IBM.COM                      IN NS     MIDVMB.LAHULPE.IBM.COM
 ..                                  IN NS     SRI-NIC.ARPA
SRI-NIC.ARPA                         IN A      10.0.0.51
                                     IN A      26.0.0.73
MVSA.PARIS.IBM.COM                   IN A      9.37.17.2
MIDVMB.LAHULPE.IBM.COM               IN A      9.36.1.4
</pre>
This simply means that all queries for domain paris.ibm.com will be forwarded
to mvsa.paris.ibm.com, all queries for lahulpe.ibm.com to
midvmb.lahulpe.ibm.com, and all others to the root server sri-nic.arpa.

<h5><a name="H523">Full-function name server</a>
</h5>
<p>The name server software is run in a separate address space and resolver
programs use the loopback address. The name server can operate as a primary
and/or a secondary name server. The domain data is stored in a DB2 SQL table.
<p>The name server software is run in the NAMESRV service virtual machine and
resolver programs use the loopback address. The name server can operate as a
primary and/or a secondary name server. The domain data is stored in an SQL/DS
database.
<p><i>Mail eXchanger (MX)</i> <a name=index1557>records</a> are supported. They
are only used by SMTP (see <a href="3376c46.html#smtpdom">SMTP and the Domain
Name System</a> for more details about the use of MX records).
<p>The NSMAIN DATA contains PRIMARY and/or SECONDARY statements instead of a
CACHINGONLY statement. An example is shown in
<a href="3376c45.html#fignsmainm">Figure - Sample NSMAIN DATA File for MVS</a>.
<br><br><a name=fignsmainm>
<pre>
;
DB2SYSNAME SYS1      ; Define Local DB2 subsystem
PRIMARY watson.ibm.com WATSON  ; Use authoritative tables WATSON0, WATSON1
SECONDARY ibm.com IBM 129.34.128.245
;                    ; Transfer domain data for ibm.com into tables
;                    ; IBM0 and IBM1 from 129.34.128.245
;
NEGATIVECACHING                 ; The NS will store negative query answers
STANDARDQUERYCACHE     100      ; The number of Standard queries to cache
INTERMEDIARYQUERYCACHE  50      ; The number of Intermediary queries to cache
INVERSEQUERYCACHE        5      ; The number of Inverse queries to cache
;
;
LRUTIME                300      ; Time an entry must be in the cache before it
                                ; can be replaced by the LRU algorithm
HOSTNAMECASE         UPPER      ; Host names in the DB2 tables are in upper case
DOMAINNAMEPORT          53      ; Listen on port N, default is 53
UDPONLY                       ; Use UDP only when contacting a remove NS
UDPRETRYINTERVAL         5      ; After N seconds, try next remote NS
; NORECURSION                   ; Prevents NS from performing recursion
TRACE               QUEUE       ; Display query origination and query name
</pre>
<br><i>Figure: Sample NSMAIN DATA File for MVS</i><br><br>
<p>A sample DB2 configuration is shown schematically in
<a href="3376c45.html#figmvsdb2">Figure - DB2 Storage Group, Tablespace, and
Table Definition</a>.
<br><br><a name=figmvsdb2>
<img src="3376f116.gif"></a>
<br><i>Figure: DB2 Storage Group, Tablespace, and Table Definition</i><br><br>

<h5><a name="H526">User Applications</a>
</h5>
<p>MVS provides the NSLOOKUP and DIG programs to query name servers. For more
information on these programs, please refer to <i>IBM TCP/IP Version 3 Release
1 for MVS: User's Guide</i>.
<p>For more information on their installation, please refer to the <i>IBM
TCP/IP Version 3 Release 1 for MVS: Customization and Administration Guide</i>.

<h4><a name="H527">4.5.10.3  OS/400</a>
</h4>
<p>TCP/IP on OS/400 systems does not support the name server function but can
use a remote name server (that is, the user applications include a stub
resolver). A flat name space is supported and the local host table is
configured using the OS/400 TCP/IP configuration panels.

<h4><a name="H528">4.5.10.4  AIX</a>
</h4>
<p>Domain name services are fully implemented in AIX/6000. AIX/ESA provides
similar services.  We shall concentrate on the AIX/6000 implementation here.
The following types of name server are supported:
<ol>
<li>Primary name server
<li>Secondary name server
<li>Caching-only server
<li>Forwarder or client server (not on AIX/ESA)
<li>Remote server
</ol>
<p>The AIX resolver routines, gethostbyaddr() and gethostbyname(), attempt to
resolve names using the following procedure:
<ul>
<li>If the file /etc/resolv.conf does not exist, then the resolver routines
assume that the local network is a flat network. They then use the /etc/hosts
file to map the name to an address.
<li>Otherwise, they assume the local network is a domain network and attempt to
use the following sources in the order listed:
<ol>
<li>The domain name server
<li>The local /etc/hosts file
</ol>
</ul>
<p>The <i>named</i> <a name=index1558>daemon</a> provides the name server
function. It is controlled by the AIX SRC (system resource control). It can be
started automatically with each system restart by either using the <i>smit
stnamed</i> fastpath command or by editing the rc.tcpip file to uncomment the
line:
<pre>
#start /etc/named "$src_running"
</pre>
The named daemon can also be started by issuing the <i>startsrc -s named</i>
command.
<p>An AIX host can be configured to use a name server by using the following
steps:
<ul>
<li>Create the /etc/resolv.conf file to include the domain name and up to 16
name server entries. For example:
<pre>
domain itsc.raleigh.ibm.com
nameserver 9.67.38.101
nameserver 9.67.38.96
</pre>
<li>Create the /etc/named.boot file to specify the name and the type of the
local named daemon.
<li>Create the /etc/named.* files to define further data for the daemon. The
format of the files follows the standard Resource Record format.
</ul>
<p>The daemon also supports resource records for mail of types MB (mailbox
domain name), MR (mail rename domain name), MG (mail group member), MINFO
(mailbox or mail list information) and MX (mail exchange).

<h5><a name="H529">User Applications</a>
</h5>
<p>AIX/6000 includes the host and nslookup programs. AIX/6000 also provides the
dig program to query name servers.

<h4><a name="H530">4.5.10.5  OS/2</a>
</h4>
<p>TCP/IP for OS/2 provides a similar implementation to that in AIX. The
following types of name server are supported:
<ol>
<li>Primary name server
<li>Secondary name server
<li>Caching-only server
<li>Remote server
<li>Flat name space
</ol>
<p>In order to use any of the first three, the <i>named</i> server which is
included in the Domain Name Server kit is required.
<p>The OS/2 resolver routines, gethostbyaddr() and gethostbyname() attempt to
resolve names using the following procedure:
<ul>
<li>If the file \TCPIP\ETC\RESOLV does not exist, then the resolver routines
assume that the local network is a flat network. They then use TCPIP\ETC\HOSTS
file to map the name to an address.
<li>Otherwise, they assume the local network is a domain network and attempt to
use the following sources in the order listed:
<ol>
<li>The domain name server.
<li>The local \TCPIP\ETC\HOSTS file.
</ol>
</ul>
<p>The <i>named</i> <a name=index1559>daemon</a> provides the name server
function. It is configured using the \TCPIP\ETC\NAMEDB\NAMED.BT file.

<h5><a name="H531">User Applications</a>
</h5>
<p>The HOST and NSLOOKUP programs are included in TCP/IP for OS/2.
<p>Please refer to <i>IBM TCP/IP Version 2.0 for OS/2: User's Guide</i> for
more details about the HOST and NSLOOKUP commands.

<h4><a name="H532">4.5.10.6  DOS</a>
</h4>
<p>TCP/IP for DOS system does not support the name server function but can use
a remote name server (that is, the user applications include a stub resolver).
A flat name space is supported and the local host table is found in the
\TCPDOS\ETC\HOSTS file.

<h5><a name="H533">User Applications</a>
</h5>
<p>The HOST program is included with TCP/IP for DOS.
<p>Please refer to <i>IBM TCP/IP Version 2.1.1 for DOS: User's Guide</i> for
more details about the HOST command.

<p><a href="./3376fm.html"><img src="fm2html-toc.gif">Table of Contents</a>  <a href="3376c46.html#smtp"><img src="fm2html-next.gif">Simple
Mail Transfer Protocol (SMTP)</a><br>
</html>
