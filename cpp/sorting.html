<head>
<TITLE>Programming - Sorting</TITLE>
</head>
<BODY BGCOLOR="#fafafa" TEXT="#000044" link="#000099" vlink="#990000" alink="#00ff00">
<CENTER><H2>Introduction to Computer Science - C++</H2></CENTER>
<CENTER><H3>Sorting Algorithms</H3></CENTER>
<p> &nbsp; &nbsp; &nbsp; &nbsp;
If we have an array of numbers in no particular order, we might want to 
sort them into ascending or descending order.  This is called sorting.
The most basic sorting algorithm is called Select Sort.  The principle
of the select sort is to traverse the array and find the index
of the largest value.  Then place the largest value at the end of the array.
The array is repeatedly traversed, each time stopping one index sooner.
Each traversal sorts one more number into its final position.
The array will need to be traversed n times where n is the number of 
elements in the array.
Here is one version of Select Sort:

<pre>

void swap( short sorting_array[], short i, short j );
void sortArray(short vect[], short len);

int main()
{

short array[]={4,6,7,2,67,8,2,44,1,2,7};
 int i;
 for(i=0; i &lt; 11; i++)
   cout &lt;&lt; array[i] &lt;&lt; ", ";
 cout &lt;&lt;  endl;

 sortArray(array, 11);

 for(i=0; i &lt; 11; i++)
   cout &lt;&lt; array[i] &lt;&lt; ", ";
 cout &lt;&lt;  endl;

}

void sortArray(short vect[], short len)
{
  short biggest,i,j;
  for(j=0; j &lt; len ; j++)
    {
      biggest=0; //we will assume the biggest value is at array index 0
      for(i=0; i &lt; len-j; i++) /*each round one largest number is placed in 
			     it correct position at end
			     therefore stop at len-j*/
        if(vect[i] &lt;  vect[biggest] )
	  biggest=i;
      swap(vect,biggest,i-1);
    }
}


void swap( short sorting_array[], short i, short j )
{
  short hold = sorting_array[i];
  sorting_array[i] = sorting_array[j];
  sorting_array[j] = hold;
  return;
}
</pre>



Bubble Sort is another basic sorting algorithm. It gets its name from it 
proberty of bubbling up larger numbers to the end of the array.  The basic
idea is to compare each number to its neighbor, the larger of the two being 
placed to the index of the higher position (or lower if a descending
sort is desired).  The is repeated n <sup>2</sup> times.
Here is a code example :
<p>

<pre>
#define SIZE 10
void main( )
 {
   int my_array[SIZE] = { 2, 6, 4, 8, 10, 12, 89, 68, 45, 37 };
   bool there_was_a_swap;

   showArray( my_array, SIZE );
   for ( int c=0; c &lt;  SIZE ; c++ )
      {
      there_was_a_swap = false;
      for ( int element = 0 ; element &lt;  SIZE-1 ; element++ )
         {
         if ( my_array[element] &gt;  my_array[element + 1] )
             {  
             swap( my_array, element, element + 1 );
             there_was_a_swap = true;
             }
         }//end inner for loop

      if ( there_was_a_swap == false )
          {
          break;
          }
      }//end outer for loop, end sorting algorithm
   showArray( my_array,SIZE );
     }//end main

 void showArray( int array[], int size )
 {
  for ( int c = 0 ; c &lt;  size ; c++ )
  {
   cout &lt;&lt; array[c] &lt;&lt; ", " ;
  }
   cout&lt;&lt;endl ;
  return;
 }
 
void swap( int sorting_array[], int i, int j )
 {
  int hold = sorting_array[i];
  sorting_array[i] = sorting_array[j];
  sorting_array[j] = hold;
  return;
 }
</pre>

<p>
This is called bubble sort because the correct values bubble up to the surface.
After each traversal, not only is the largest number placed at the end,
but other numbers along the way have been adjusted so as to improve their location
in the array.  In some circumstances this may cause the array to
be in correct order sooner. In general,
we must traverse n numbers n times, or n <sup>2</sup>  times. 
But if the array becomes sorted sooner we can stop earlier.  We test this possibility by 
checking if we have traversed the array without making any swaps.  If we made
no swaps then we know the array is sorted already.
We can also improve the efficiency a bit by noticing that we do not need to check the 
last element which was put into its correct place. In my version, I check all the values
every traversal.  You can try to improve the above program by having it
check only the as yet unsorted elements.

<p>
&copy Nachum Danzig December 2003 - December 2006

</body>
</html>

